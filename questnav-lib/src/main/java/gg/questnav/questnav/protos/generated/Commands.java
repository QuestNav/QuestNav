// Code generated by protocol buffer compiler. Do not edit!
package gg.questnav.questnav.protos.generated;

import edu.wpi.first.math.proto.Geometry2D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.Utf8String;

public final class Commands {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(7504,
        "Cg5jb21tYW5kcy5wcm90bxIYcXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzGhBnZW9tZXRyeTJkLnByb3Rv" + 
        "Il4KIFByb3RvYnVmUXVlc3ROYXZQb3NlUmVzZXRQYXlsb2FkEjoKC3RhcmdldF9wb3NlGAEgASgLMhku" + 
        "d3BpLnByb3RvLlByb3RvYnVmUG9zZTJkUgp0YXJnZXRQb3NlIvIBChdQcm90b2J1ZlF1ZXN0TmF2Q29t" + 
        "bWFuZBJBCgR0eXBlGAEgASgOMi0ucXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzLlF1ZXN0TmF2Q29tbWFu" + 
        "ZFR5cGVSBHR5cGUSHQoKY29tbWFuZF9pZBgCIAEoDVIJY29tbWFuZElkEmoKEnBvc2VfcmVzZXRfcGF5" + 
        "bG9hZBgKIAEoCzI6LnF1ZXN0bmF2LnByb3Rvcy5jb21tYW5kcy5Qcm90b2J1ZlF1ZXN0TmF2UG9zZVJl" + 
        "c2V0UGF5bG9hZEgAUhBwb3NlUmVzZXRQYXlsb2FkQgkKB3BheWxvYWQifwofUHJvdG9idWZRdWVzdE5h" + 
        "dkNvbW1hbmRSZXNwb25zZRIdCgpjb21tYW5kX2lkGAEgASgNUgljb21tYW5kSWQSGAoHc3VjY2VzcxgC" + 
        "IAEoCFIHc3VjY2VzcxIjCg1lcnJvcl9tZXNzYWdlGAMgASgJUgxlcnJvck1lc3NhZ2UqQwoTUXVlc3RO" + 
        "YXZDb21tYW5kVHlwZRIcChhDT01NQU5EX1RZUEVfVU5TUEVDSUZJRUQQABIOCgpQT1NFX1JFU0VUEAFC" + 
        "QwolZ2cucXVlc3RuYXYucXVlc3RuYXYucHJvdG9zLmdlbmVyYXRlZKoCGVF1ZXN0TmF2LlByb3Rvcy5H" + 
        "ZW5lcmF0ZWRKqTUKBxIFAAPRAQEKCAoBDBIDAAMVCvYFCgECEgMWACEy6wUqCiBRdWVzdE5hdiBDb21t" + 
        "YW5kcyBQcm90b2NvbCBCdWZmZXIgRGVmaW5pdGlvbnMKIAogVGhpcyBmaWxlIGRlZmluZXMgdGhlIGNv" + 
        "bW1hbmQgc3lzdGVtIGZvciBRdWVzdE5hdiwgd2hpY2ggYWxsb3dzIGV4dGVybmFsIHN5c3RlbXMKIChz" + 
        "dWNoIGFzIHJvYm90IGNvZGUpIHRvIHNlbmQgY29tbWFuZHMgdG8gdGhlIFF1ZXN0IGhlYWRzZXQgZm9y" + 
        "IHZhcmlvdXMgb3BlcmF0aW9ucy4KIFRoZSBjb21tYW5kIHN5c3RlbSBpcyBkZXNpZ25lZCB0byBiZSBl" + 
        "eHRlbnNpYmxlLCBhbGxvd2luZyBuZXcgY29tbWFuZCB0eXBlcyB0byBiZQogYWRkZWQgd2l0aG91dCBi" + 
        "cmVha2luZyBleGlzdGluZyBpbXBsZW1lbnRhdGlvbnMuCiAKIEtleSBGZWF0dXJlczoKIC0gQXN5bmNo" + 
        "cm9ub3VzIGNvbW1hbmQgZXhlY3V0aW9uIHdpdGggcmVzcG9uc2UgdHJhY2tpbmcKIC0gRXh0ZW5zaWJs" + 
        "ZSBjb21tYW5kIHR5cGUgc3lzdGVtCiAtIFR5cGUtc2FmZSBwYXlsb2FkIHN5c3RlbSB1c2luZyBvbmVv",
        "ZgogLSBFcnJvciBoYW5kbGluZyBhbmQgc3RhdHVzIHJlcG9ydGluZwogCiBVc2FnZSBGbG93OgogMS4g" + 
        "Q2xpZW50IHNlbmRzIFByb3RvYnVmUXVlc3ROYXZDb21tYW5kIHdpdGggdW5pcXVlIGNvbW1hbmRfaWQK" + 
        "IDIuIFF1ZXN0TmF2IHByb2Nlc3NlcyB0aGUgY29tbWFuZCBhc3luY2hyb25vdXNseQogMy4gUXVlc3RO" + 
        "YXYgc2VuZHMgYmFjayBQcm90b2J1ZlF1ZXN0TmF2Q29tbWFuZFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcg" + 
        "Y29tbWFuZF9pZAoKCAoBCBIDFwA2CgkKAgglEgMXADYKCAoBCBIDGAA+CgkKAggBEgMYAD4KPwoCAwAS" + 
        "AxsAGho0IEltcG9ydCBnZW9tZXRyeSBtZXNzYWdlcyBmb3IgcG9zZS1yZWxhdGVkIGNvbW1hbmRzCgrQ" + 
        "AwoCBQASBCkAOwEawwMqCiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgY29tbWFuZCB0eXBlcyBpbiB0" + 
        "aGUgUXVlc3ROYXYgc3lzdGVtLgogCiBUaGlzIGVudW0gZGVmaW5lcyBhbGwgdGhlIGRpZmZlcmVudCB0" + 
        "eXBlcyBvZiBjb21tYW5kcyB0aGF0IGNhbiBiZSBzZW50IHRvCiB0aGUgUXVlc3QgaGVhZHNldC4gVGhl" + 
        "IGVudW0gaXMgZGVzaWduZWQgdG8gYmUgZXh0ZW5zaWJsZSAtIG5ldyBjb21tYW5kIHR5cGVzCiBjYW4g" + 
        "YmUgYWRkZWQgd2l0aG91dCBicmVha2luZyBleGlzdGluZyBjbGllbnRzLgogCiBEZXNpZ24gTm90ZXM6" + 
        "CiAtIFZhbHVlcyBzdGFydCBmcm9tIDAgYXMgcmVxdWlyZWQgYnkgcHJvdG8zCiAtIFVOU1BFQ0lGSUVE" + 
        "IHZhbHVlICgwKSBpcyByZXNlcnZlZCBmb3IgZXJyb3IgaGFuZGxpbmcKIC0gQ29tbWFuZCB2YWx1ZXMg" + 
        "c2hvdWxkIGJlIGFzc2lnbmVkIGluY3JlbWVudGFsbHkgZm9yIGNsYXJpdHkKCgoKAwUAARIDKQUYCkAK" + 
        "BAUAAgASAyoCHyIzIERlZmF1bHQvaW52YWxpZCBjb21tYW5kIHR5cGUgKHJlcXVpcmVkIGJ5IHByb3Rv" + 
        "MykKCgwKBQUAAgABEgMqAhoKDAoFBQACAAISAyodHgrXAgoEBQACARIDNQIRGskCKgogUE9TRV9SRVNF" + 
        "VDogUmVzZXRzIHRoZSByb2JvdCdzIHBvc2UgZXN0aW1hdGlvbiB0byBhIHNwZWNpZmllZCB0YXJnZXQg" + 
        "cG9zZS4KIAogVGhpcyBjb21tYW5kIGlzIHVzZWQgdG8gY29ycmVjdCBkcmlmdCBpbiB0aGUgdHJhY2tp" + 
        "bmcgc3lzdGVtIGJ5IHNldHRpbmcKIHRoZSByb2JvdCdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiB0" + 
        "byBrbm93biB2YWx1ZXMuIFR5cGljYWxseSB1c2VkIHdoZW4KIHRoZSByb2JvdCBpcyBwbGFjZWQgYXQg",
        "YSBrbm93biBsb2NhdGlvbiBvbiB0aGUgZmllbGQuCiAKIFJlcXVpcmVzOiBQcm90b2J1ZlF1ZXN0TmF2" + 
        "UG9zZVJlc2V0UGF5bG9hZAoKDAoFBQACAQESAzUCDAoMCgUFAAIBAhIDNQ8QCssECgIEABIESwBYARq+" + 
        "BCoKIFBheWxvYWQgbWVzc2FnZSBmb3IgdGhlIFBPU0VfUkVTRVQgY29tbWFuZC4KIAogVGhpcyBtZXNz" + 
        "YWdlIGNvbnRhaW5zIHRoZSBkYXRhIG5lZWRlZCB0byBleGVjdXRlIGEgcG9zZSByZXNldCBvcGVyYXRp" + 
        "b24uCiBUaGUgcG9zZSByZXNldCBjb21tYW5kIGFsbG93cyBleHRlcm5hbCBzeXN0ZW1zIHRvIGNvcnJl" + 
        "Y3QgdGhlIFF1ZXN0J3MKIHVuZGVyc3RhbmRpbmcgb2YgdGhlIHJvYm90J3MgcG9zaXRpb24gYW5kIG9y" + 
        "aWVudGF0aW9uIG9uIHRoZSBmaWVsZC4KIAogQ29vcmRpbmF0ZSBTeXN0ZW06CiAtIFVzZXMgV1BJTGli" + 
        "IGZpZWxkLXJlbGF0aXZlIGNvb3JkaW5hdGUgc3lzdGVtCiAtIFgtYXhpczogRm9yd2FyZCAodG93YXJk" + 
        "cyBvcHBvc2luZyBhbGxpYW5jZSkKIC0gWS1heGlzOiBMZWZ0ICh3aGVuIGZhY2luZyBmb3J3YXJkKQog" + 
        "LSBSb3RhdGlvbjogQ291bnRlci1jbG9ja3dpc2UgcG9zaXRpdmUgKHN0YW5kYXJkIG1hdGhlbWF0aWNh" + 
        "bCBjb252ZW50aW9uKQogLSBPcmlnaW46IFR5cGljYWxseSBhdCBvbmUgY29ybmVyIG9mIHRoZSBmaWVs" + 
        "ZCAoc2VlIGZpZWxkIGxheW91dCBkb2N1bWVudGF0aW9uKQoKCgoDBAABEgNLCCgK0QIKBAQAAgASA1cC" + 
        "KxrDAioKIFRoZSB0YXJnZXQgcG9zZSB0byByZXNldCB0aGUgcm9ib3QgdG8uCiAKIFRoaXMgc2hvdWxk" + 
        "IHJlcHJlc2VudCB0aGUgcm9ib3QncyBhY3R1YWwgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9uIHRo" + 
        "ZSBmaWVsZAogaW4gdGhlIFdQSUxpYiBjb29yZGluYXRlIHN5c3RlbS4gVGhlIFF1ZXN0IHdpbGwgdXBk" + 
        "YXRlIGl0cyBpbnRlcm5hbCB0cmFja2luZwogdG8gbWF0Y2ggdGhpcyBwb3NlLCBlZmZlY3RpdmVseSBj" + 
        "b3JyZWN0aW5nIGFueSBhY2N1bXVsYXRlZCBkcmlmdC4KIAogVW5pdHM6CiAtIFRyYW5zbGF0aW9uOiBt" + 
        "ZXRlcnMKIC0gUm90YXRpb246IHJhZGlhbnMKCgwKBQQAAgAGEgNXAhoKDAoFBAACAAESA1cbJgoMCgUE" + 
        "AAIAAxIDVykqCqgFCgIEARIFagCYAQEamgUqCiBNYWluIGNvbW1hbmQgbWVzc2FnZSBzZW50IHRvIHRo" + 
        "ZSBRdWVzdE5hdiBzeXN0ZW0uCiAKIFRoaXMgaXMgdGhlIHByaW1hcnkgbWVzc2FnZSB0eXBlIHVzZWQg",
        "dG8gc2VuZCBjb21tYW5kcyBmcm9tIGV4dGVybmFsIHN5c3RlbXMKIChsaWtlIHJvYm90IGNvZGUpIHRv" + 
        "IHRoZSBRdWVzdCBoZWFkc2V0LiBFYWNoIGNvbW1hbmQgaW5jbHVkZXMgYSB0eXBlIGlkZW50aWZpZXIs" + 
        "CiBhIHVuaXF1ZSB0cmFja2luZyBJRCwgYW5kIG9wdGlvbmFsIHBheWxvYWQgZGF0YSBzcGVjaWZpYyB0" + 
        "byB0aGUgY29tbWFuZCB0eXBlLgogCiBUaGUgY29tbWFuZCBzeXN0ZW0gaXMgZGVzaWduZWQgZm9yIGFz" + 
        "eW5jaHJvbm91cyBvcGVyYXRpb24gLSBjb21tYW5kcyBhcmUgc2VudAogYW5kIHJlc3BvbnNlcyBhcmUg" + 
        "cmVjZWl2ZWQgc2VwYXJhdGVseSwgbWF0Y2hlZCBieSB0aGUgY29tbWFuZF9pZCBmaWVsZC4KIAogTWVz" + 
        "c2FnZSBGbG93OgogMS4gQ2xpZW50IGNyZWF0ZXMgY29tbWFuZCB3aXRoIHVuaXF1ZSBjb21tYW5kX2lk" + 
        "CiAyLiBDbGllbnQgc2V0cyBhcHByb3ByaWF0ZSB0eXBlIGFuZCBwYXlsb2FkCiAzLiBDbGllbnQgc2Vu" + 
        "ZHMgY29tbWFuZCB0byBRdWVzdAogNC4gUXVlc3QgcHJvY2Vzc2VzIGNvbW1hbmQgYW5kIHNlbmRzIHJl" + 
        "c3BvbnNlIHdpdGggbWF0Y2hpbmcgY29tbWFuZF9pZAoKCgoDBAEBEgNqCB8K3wEKBAQBAgASA3ICHxrR" + 
        "ASoKIFRoZSB0eXBlIG9mIGNvbW1hbmQgYmVpbmcgc2VudC4KIAogVGhpcyBmaWVsZCBkZXRlcm1pbmVz" + 
        "IHdoaWNoIHBheWxvYWQgKGlmIGFueSkgc2hvdWxkIGJlIHBvcHVsYXRlZCBhbmQKIGhvdyB0aGUgUXVl" + 
        "c3Qgc2hvdWxkIHByb2Nlc3MgdGhlIGNvbW1hbmQuIFNlZSBRdWVzdE5hdkNvbW1hbmRUeXBlCiBlbnVt" + 
        "IGZvciBhdmFpbGFibGUgY29tbWFuZCB0eXBlcy4KCgwKBQQBAgAGEgNyAhUKDAoFBAECAAESA3IWGgoM" + 
        "CgUEAQIAAxIDch0eCq8DCgQEAQIBEgN/AhgaoQMqCiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBj" + 
        "b21tYW5kIGluc3RhbmNlLgogCiBUaGlzIElEIGlzIHVzZWQgdG8gbWF0Y2ggY29tbWFuZHMgd2l0aCB0" + 
        "aGVpciByZXNwb25zZXMgaW4gYXN5bmNocm9ub3VzCiBjb21tdW5pY2F0aW9uLiBUaGUgY2xpZW50IHNo" + 
        "b3VsZCBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciBlYWNoIGNvbW1hbmQKIHRvIGF2b2lkIGNvbmZ1c2lv" + 
        "bi4gVGhlIFF1ZXN0IHdpbGwgZWNobyB0aGlzIElEIGluIHRoZSByZXNwb25zZSBtZXNzYWdlLgogCiBS" + 
        "ZWNvbW1lbmRlZDogVXNlIGluY3JlbWVudGluZyBpbnRlZ2VycyBvciB0aW1lc3RhbXBzIGZvciB1bmlx",
        "dWVuZXNzLgogCiBOb3RlOiBGb3IgRlJDIHVzZXJzLCB0aGUgdmVuZG9yIGRlcGVuZGVuY3kgd2lsbCBo" + 
        "YW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LgoKDAoFBAECAQUSA38CCAoMCgUEAQIBARIDfwkTCgwKBQQB" + 
        "AgEDEgN/FhcK2QIKBAQBCAASBooBApcBAxrIAioKIENvbW1hbmQtc3BlY2lmaWMgcGF5bG9hZCBkYXRh" + 
        "LgogCiBUaGlzIG9uZW9mIGZpZWxkIGNvbnRhaW5zIHRoZSBzcGVjaWZpYyBkYXRhIG5lZWRlZCBmb3Ig" + 
        "ZWFjaCBjb21tYW5kIHR5cGUuCiBPbmx5IG9uZSBwYXlsb2FkIGZpZWxkIHdpbGwgYmUgc2V0LCBjb3Jy" + 
        "ZXNwb25kaW5nIHRvIHRoZSBjb21tYW5kIHR5cGUuCiBDb21tYW5kcyB0aGF0IGRvbid0IHJlcXVpcmUg" + 
        "YWRkaXRpb25hbCBkYXRhIGRvbid0IG5lZWQgYSBwYXlsb2FkIGVudHJ5LgogCiBGaWVsZCBudW1iZXJp" + 
        "bmcgc3RhcnRzIGF0IDEwIHRvIGxlYXZlIHJvb20gZm9yIGZ1dHVyZSBjb21tb24gZmllbGRzLgoKDQoF" + 
        "BAEIAAESBIoBCA8KWgoEBAECAhIEjwEEPRpMKgogUGF5bG9hZCBmb3IgUE9TRV9SRVNFVCBjb21tYW5k" + 
        "cy4KIFNldCB0aGlzIGZpZWxkIHdoZW4gdHlwZSA9IFBPU0VfUkVTRVQuCgoNCgUEAQICBhIEjwEEJAoN" + 
        "CgUEAQICARIEjwElNwoNCgUEAQICAxIEjwE6PAqTBgoCBAISBqwBANEBARqEBioKIFJlc3BvbnNlIG1l" + 
        "c3NhZ2Ugc2VudCBiYWNrIGFmdGVyIHByb2Nlc3NpbmcgYSBjb21tYW5kLgogCiBUaGlzIG1lc3NhZ2Ug" + 
        "aXMgc2VudCBieSB0aGUgUXVlc3QgYmFjayB0byB0aGUgY2xpZW50IGFmdGVyIHByb2Nlc3NpbmcKIGEg" + 
        "UHJvdG9idWZRdWVzdE5hdkNvbW1hbmQuIEl0IHByb3ZpZGVzIHN0YXR1cyBpbmZvcm1hdGlvbiBhYm91" + 
        "dCB3aGV0aGVyCiB0aGUgY29tbWFuZCB3YXMgZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCBhbnkgZXJy" + 
        "b3IgZGV0YWlscyBpZiBpdCBmYWlsZWQuCiAKIFRoZSByZXNwb25zZSBpcyBtYXRjaGVkIHRvIHRoZSBv" + 
        "cmlnaW5hbCBjb21tYW5kIHVzaW5nIHRoZSBjb21tYW5kX2lkIGZpZWxkLAogYWxsb3dpbmcgZm9yIHBy" + 
        "b3BlciBhc3luY2hyb25vdXMgY29tbWFuZCBoYW5kbGluZyBldmVuIHdoZW4gbXVsdGlwbGUKIGNvbW1h" + 
        "bmRzIGFyZSBpbiBmbGlnaHQgc2ltdWx0YW5lb3VzbHkuCiAKIFJlc3BvbnNlIFRpbWluZzoKIC0gUmVz" + 
        "cG9uc2VzIGFyZSBzZW50IGFmdGVyIGNvbW1hbmQgcHJvY2Vzc2luZyBjb21wbGV0ZXMKIC0gU29tZSBj",
        "b21tYW5kcyBtYXkgdGFrZSB0aW1lIHRvIGV4ZWN1dGUgKGUuZy4sIHBvc2UgcmVzZXQgd2l0aCB2YWxp" + 
        "ZGF0aW9uKQogLSBDbGllbnRzIHNob3VsZCBpbXBsZW1lbnQgdGltZW91dHMgZm9yIGNvbW1hbmQgcmVz" + 
        "cG9uc2VzCiAKIE5vdGU6IEZvciBGUkMgdXNlcnMsIHRoZSB2ZW5kb3IgZGVwZW5kZW5jeSB3aWxsIGhh" + 
        "bmRsZSByZXNwb25zZSBtYXRjaGluZyBhdXRvbWF0aWNhbGx5LgoKCwoDBAIBEgSsAQgnCpMCCgQEAgIA" + 
        "EgS0AQIYGoQCKgogQ29tbWFuZCBJRCB0aGF0IG1hdGNoZXMgdGhlIG9yaWdpbmFsIGNvbW1hbmQuCiAK" + 
        "IFRoaXMgZmllbGQgZWNob2VzIHRoZSBjb21tYW5kX2lkIGZyb20gdGhlIG9yaWdpbmFsIFByb3RvYnVm" + 
        "UXVlc3ROYXZDb21tYW5kCiB0aGF0IHRoaXMgcmVzcG9uc2UgY29ycmVzcG9uZHMgdG8uIENsaWVudHMg" + 
        "dXNlIHRoaXMgdG8gbWF0Y2ggcmVzcG9uc2VzCiB3aXRoIHRoZWlyIG9yaWdpbmFsIGNvbW1hbmRzIGlu" + 
        "IGFzeW5jaHJvbm91cyBjb21tdW5pY2F0aW9uLgoKDQoFBAICAAUSBLQBAggKDQoFBAICAAESBLQBCRMK" + 
        "DQoFBAICAAMSBLQBFhcKhgMKBAQCAgESBMABAhMa9wIqCiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29t" + 
        "bWFuZCB3YXMgZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5LgogCiB0cnVlOiAgQ29tbWFuZCBjb21wbGV0ZWQg" + 
        "c3VjY2Vzc2Z1bGx5CiBmYWxzZTogQ29tbWFuZCBmYWlsZWQgKHNlZSBlcnJvcl9tZXNzYWdlIGZvciBk" + 
        "ZXRhaWxzKQogCiBOb3RlOiBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgbWVhbnMgdGhlIGNvbW1hbmQgd2Fz" + 
        "IHByb2Nlc3NlZCwgYnV0IGRvZXNuJ3QKIG5lY2Vzc2FyaWx5IGd1YXJhbnRlZSB0aGUgZGVzaXJlZCBv" + 
        "dXRjb21lIChlLmcuLCBwb3NlIHJlc2V0IG1pZ2h0IHN1Y2NlZWQKIGJ1dCB0cmFja2luZyBjb3VsZCBz" + 
        "dGlsbCBiZSBwb29yIGR1ZSB0byBlbnZpcm9ubWVudGFsIGNvbmRpdGlvbnMpLgoKDQoFBAICAQUSBMAB" + 
        "AgYKDQoFBAICAQESBMABBw4KDQoFBAICAQMSBMABERIKyAMKBAQCAgISBNABAhsauQMqCiBIdW1hbi1y" + 
        "ZWFkYWJsZSBlcnJvciBtZXNzYWdlIHdoZW4gc3VjY2VzcyA9IGZhbHNlLgogCiBUaGlzIGZpZWxkIHBy" + 
        "b3ZpZGVzIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHdoeSBhIGNvbW1hbmQgZmFpbGVkLgogSXQg" + 
        "c2hvdWxkIGJlIGVtcHR5IG9yIGlnbm9yZWQgd2hlbiBzdWNjZXNzID0gdHJ1ZS4KIAogRXJyb3IgbWVz",
        "c2FnZXMgYXJlIGludGVuZGVkIGZvciBkZWJ1Z2dpbmcgYW5kIGxvZ2dpbmcgcHVycG9zZXMuCiBUaGV5" + 
        "IG1heSBpbmNsdWRlIHRlY2huaWNhbCBkZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlIGNhdXNlLgogCiBF" + 
        "eGFtcGxlczoKIC0gIkludmFsaWQgcG9zZSBjb29yZGluYXRlczogeCB2YWx1ZSBvdXQgb2YgZmllbGQg" + 
        "Ym91bmRzIgogLSAiVHJhY2tpbmcgc3lzdGVtIG5vdCBpbml0aWFsaXplZCIKIC0gIlVua25vd24gY29t" + 
        "bWFuZCB0eXBlIgoKDQoFBAICAgUSBNABAggKDQoFBAICAgESBNABCRYKDQoFBAICAgMSBNABGRpiBnBy" + 
        "b3RvMw==");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("commands.proto", "questnav.protos.commands", descriptorData, Geometry2D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavPoseResetPayload_descriptor = descriptor.internalContainedType(62, 94, "ProtobufQuestNavPoseResetPayload", "questnav.protos.commands.ProtobufQuestNavPoseResetPayload");

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavCommand_descriptor = descriptor.internalContainedType(159, 242, "ProtobufQuestNavCommand", "questnav.protos.commands.ProtobufQuestNavCommand");

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavCommandResponse_descriptor = descriptor.internalContainedType(403, 127, "ProtobufQuestNavCommandResponse", "questnav.protos.commands.ProtobufQuestNavCommandResponse");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     * *
     *  Enumeration of available command types in the QuestNav system.
     *  
     *  This enum defines all the different types of commands that can be sent to
     *  the Quest headset. The enum is designed to be extensible - new command types
     *  can be added without breaking existing clients.
     *  
     *  Design Notes:
     *  - Values start from 0 as required by proto3
     *  - UNSPECIFIED value (0) is reserved for error handling
     *  - Command values should be assigned incrementally for clarity
     * </pre>
     *
     * Protobuf enum {@code QuestNavCommandType}
     */
    public enum QuestNavCommandType implements ProtoEnum<QuestNavCommandType> {
        /**
         * <pre>
         *  Default/invalid command type (required by proto3)
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        COMMAND_TYPE_UNSPECIFIED("COMMAND_TYPE_UNSPECIFIED", 0),

        /**
         * <pre>
         * *
         *  POSE_RESET: Resets the robot's pose estimation to a specified target pose.
         *  
         *  This command is used to correct drift in the tracking system by setting
         *  the robot's position and orientation to known values. Typically used when
         *  the robot is placed at a known location on the field.
         *  
         *  Requires: ProtobufQuestNavPoseResetPayload
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        POSE_RESET("POSE_RESET", 1);

        /**
         * <pre>
         *  Default/invalid command type (required by proto3)
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        public static final int COMMAND_TYPE_UNSPECIFIED_VALUE = 0;

        /**
         * <pre>
         * *
         *  POSE_RESET: Resets the robot's pose estimation to a specified target pose.
         *  
         *  This command is used to correct drift in the tracking system by setting
         *  the robot's position and orientation to known values. Typically used when
         *  the robot is placed at a known location on the field.
         *  
         *  Requires: ProtobufQuestNavPoseResetPayload
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        public static final int POSE_RESET_VALUE = 1;

        private final String name;

        private final int number;

        private QuestNavCommandType(String name, int number) {
            this.name = name;
            this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
            return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
            return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<QuestNavCommandType> converter() {
            return QuestNavCommandTypeConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static QuestNavCommandType forNumber(int value) {
            return QuestNavCommandTypeConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static QuestNavCommandType forNumberOr(int number, QuestNavCommandType other) {
            QuestNavCommandType value = forNumber(number);
            return value == null ? other : value;
        }

        enum QuestNavCommandTypeConverter implements ProtoEnum.EnumConverter<QuestNavCommandType> {
            INSTANCE;

            private static final QuestNavCommandType[] lookup = new QuestNavCommandType[2];

            static {
                lookup[0] = COMMAND_TYPE_UNSPECIFIED;
                lookup[1] = POSE_RESET;
            }

            @Override
            public final QuestNavCommandType forNumber(final int value) {
                if (value >= 0 && value < lookup.length) {
                    return lookup[value];
                }
                return null;
            }

            @Override
            public final QuestNavCommandType forName(final CharSequence value) {
                if (value.length() == 10) {
                    if (ProtoUtil.isEqual("POSE_RESET", value)) {
                        return POSE_RESET;
                    }
                }
                if (value.length() == 24) {
                    if (ProtoUtil.isEqual("COMMAND_TYPE_UNSPECIFIED", value)) {
                        return COMMAND_TYPE_UNSPECIFIED;
                    }
                }
                return null;
            }
        }
    }

    /**
     * <pre>
     * *
     *  Payload message for the POSE_RESET command.
     *  
     *  This message contains the data needed to execute a pose reset operation.
     *  The pose reset command allows external systems to correct the Quest's
     *  understanding of the robot's position and orientation on the field.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - X-axis: Forward (towards opposing alliance)
     *  - Y-axis: Left (when facing forward)
     *  - Rotation: Counter-clockwise positive (standard mathematical convention)
     *  - Origin: Typically at one corner of the field (see field layout documentation)
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavPoseResetPayload}
     */
    public static final class ProtobufQuestNavPoseResetPayload extends ProtoMessage<ProtobufQuestNavPoseResetPayload> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         */
        private final Geometry2D.ProtobufPose2d targetPose = Geometry2D.ProtobufPose2d.newInstance();

        private ProtobufQuestNavPoseResetPayload() {
        }

        /**
         * <pre>
         * *
         *  Payload message for the POSE_RESET command.
         *  
         *  This message contains the data needed to execute a pose reset operation.
         *  The pose reset command allows external systems to correct the Quest's
         *  understanding of the robot's position and orientation on the field.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - X-axis: Forward (towards opposing alliance)
         *  - Y-axis: Left (when facing forward)
         *  - Rotation: Counter-clockwise positive (standard mathematical convention)
         *  - Origin: Typically at one corner of the field (see field layout documentation)
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavPoseResetPayload}
         */
        public static ProtobufQuestNavPoseResetPayload newInstance() {
            return new ProtobufQuestNavPoseResetPayload();
        }

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @return whether the targetPose field is set
         */
        public boolean hasTargetPose() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @return this
         */
        public ProtobufQuestNavPoseResetPayload clearTargetPose() {
            bitField0_ &= ~0x00000001;
            targetPose.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutableTargetPose()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry2D.ProtobufPose2d getTargetPose() {
            return targetPose;
        }

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry2D.ProtobufPose2d getMutableTargetPose() {
            bitField0_ |= 0x00000001;
            return targetPose;
        }

        /**
         * <pre>
         * *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @param value the targetPose to set
         * @return this
         */
        public ProtobufQuestNavPoseResetPayload setTargetPose(
                final Geometry2D.ProtobufPose2d value) {
            bitField0_ |= 0x00000001;
            targetPose.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload copyFrom(
                final ProtobufQuestNavPoseResetPayload other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                targetPose.copyFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload mergeFrom(
                final ProtobufQuestNavPoseResetPayload other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTargetPose()) {
                getMutableTargetPose().mergeFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavPoseResetPayload)) {
                return false;
            }
            ProtobufQuestNavPoseResetPayload other = (ProtobufQuestNavPoseResetPayload) o;
            return bitField0_ == other.bitField0_
                && (!hasTargetPose() || targetPose.equals(other.targetPose));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 10);
                output.writeMessageNoTag(targetPose);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(targetPose);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavPoseResetPayload mergeFrom(final ProtoSource input) throws
                IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 10: {
                        // targetPose
                        input.readMessage(targetPose);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.targetPose, targetPose);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavPoseResetPayload mergeFrom(final JsonSource input) throws
                IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 486493634:
                    case -2084687233: {
                        if (input.isAtField(FieldNames.targetPose)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(targetPose);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clone() {
            return new ProtobufQuestNavPoseResetPayload().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), data).checkInitialized();
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), input).checkInitialized();
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavPoseResetPayload messages
         */
        public static MessageFactory<ProtobufQuestNavPoseResetPayload> getFactory() {
            return ProtobufQuestNavPoseResetPayloadFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavPoseResetPayload_descriptor;
        }

        private enum ProtobufQuestNavPoseResetPayloadFactory implements MessageFactory<ProtobufQuestNavPoseResetPayload> {
            INSTANCE;

            @Override
            public ProtobufQuestNavPoseResetPayload create() {
                return ProtobufQuestNavPoseResetPayload.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName targetPose = FieldName.forField("targetPose", "target_pose");
        }
    }

    /**
     * <pre>
     * *
     *  Main command message sent to the QuestNav system.
     *  
     *  This is the primary message type used to send commands from external systems
     *  (like robot code) to the Quest headset. Each command includes a type identifier,
     *  a unique tracking ID, and optional payload data specific to the command type.
     *  
     *  The command system is designed for asynchronous operation - commands are sent
     *  and responses are received separately, matched by the command_id field.
     *  
     *  Message Flow:
     *  1. Client creates command with unique command_id
     *  2. Client sets appropriate type and payload
     *  3. Client sends command to Quest
     *  4. Quest processes command and sends response with matching command_id
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavCommand}
     */
    public static final class ProtobufQuestNavCommand extends ProtoMessage<ProtobufQuestNavCommand> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         */
        private int commandId;

        /**
         * <pre>
         * *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         */
        private int type;

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         */
        private final ProtobufQuestNavPoseResetPayload poseResetPayload = ProtobufQuestNavPoseResetPayload.newInstance();

        private ProtobufQuestNavCommand() {
        }

        /**
         * <pre>
         * *
         *  Main command message sent to the QuestNav system.
         *  
         *  This is the primary message type used to send commands from external systems
         *  (like robot code) to the Quest headset. Each command includes a type identifier,
         *  a unique tracking ID, and optional payload data specific to the command type.
         *  
         *  The command system is designed for asynchronous operation - commands are sent
         *  and responses are received separately, matched by the command_id field.
         *  
         *  Message Flow:
         *  1. Client creates command with unique command_id
         *  2. Client sets appropriate type and payload
         *  3. Client sends command to Quest
         *  4. Quest processes command and sends response with matching command_id
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavCommand}
         */
        public static ProtobufQuestNavCommand newInstance() {
            return new ProtobufQuestNavCommand();
        }

        public boolean hasPayload() {
            return (((bitField0_ & 0x00000001)) != 0);
        }

        public ProtobufQuestNavCommand clearPayload() {
            if (hasPayload()) {
                clearPoseResetPayload();
            }
            return this;
        }

        /**
         * <pre>
         * *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearCommandId() {
            bitField0_ &= ~0x00000002;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         * *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @param value the commandId to set
         * @return this
         */
        public ProtobufQuestNavCommand setCommandId(final int value) {
            bitField0_ |= 0x00000002;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return whether the type field is set
         */
        public boolean hasType() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearType() {
            bitField0_ &= ~0x00000004;
            type = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return the type
         */
        public QuestNavCommandType getType() {
            return QuestNavCommandType.forNumber(type);
        }

        /**
         * Gets the value of the internal enum store. The result is
         * equivalent to {@link ProtobufQuestNavCommand#getType()}.getNumber().
         *
         * @return numeric wire representation
         */
        public int getTypeValue() {
            return type;
        }

        /**
         * Sets the value of the internal enum store. This does not
         * do any validity checks, so be sure to use appropriate value
         * constants from {@link QuestNavCommandType}. Setting an invalid value
         * can cause {@link ProtobufQuestNavCommand#getType()} to return null
         *
         * @param value the numeric wire value to set
         * @return this
         */
        public ProtobufQuestNavCommand setTypeValue(final int value) {
            bitField0_ |= 0x00000004;
            type = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @param value the type to set
         * @return this
         */
        public ProtobufQuestNavCommand setType(final QuestNavCommandType value) {
            bitField0_ |= 0x00000004;
            type = value.getNumber();
            return this;
        }

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @return whether the poseResetPayload field is set
         */
        public boolean hasPoseResetPayload() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearPoseResetPayload() {
            bitField0_ &= ~0x00000001;
            poseResetPayload.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePoseResetPayload()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public ProtobufQuestNavPoseResetPayload getPoseResetPayload() {
            return poseResetPayload;
        }

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public ProtobufQuestNavPoseResetPayload getMutablePoseResetPayload() {
            bitField0_ |= 0x00000001;
            return poseResetPayload;
        }

        /**
         * <pre>
         * *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @param value the poseResetPayload to set
         * @return this
         */
        public ProtobufQuestNavCommand setPoseResetPayload(
                final ProtobufQuestNavPoseResetPayload value) {
            bitField0_ |= 0x00000001;
            poseResetPayload.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavCommand copyFrom(final ProtobufQuestNavCommand other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                type = other.type;
                poseResetPayload.copyFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommand mergeFrom(final ProtobufQuestNavCommand other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasType()) {
                setTypeValue(other.type);
            }
            if (other.hasPoseResetPayload()) {
                getMutablePoseResetPayload().mergeFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            type = 0;
            poseResetPayload.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            poseResetPayload.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavCommand)) {
                return false;
            }
            ProtobufQuestNavCommand other = (ProtobufQuestNavCommand) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasType() || type == other.type)
                && (!hasPoseResetPayload() || poseResetPayload.equals(other.poseResetPayload));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 8);
                output.writeEnumNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 82);
                output.writeMessageNoTag(poseResetPayload);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeEnumSizeNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(poseResetPayload);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavCommand mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 16: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // type
                        final int value = input.readInt32();
                        if (QuestNavCommandType.forNumber(value) != null) {
                            type = value;
                            bitField0_ |= 0x00000004;
                        }
                        tag = input.readTag();
                        if (tag != 82) {
                            break;
                        }
                    }
                    case 82: {
                        // poseResetPayload
                        input.readMessage(poseResetPayload);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeEnum(FieldNames.type, type, QuestNavCommandType.converter());
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.poseResetPayload, poseResetPayload);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavCommand mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 3575610: {
                        if (input.isAtField(FieldNames.type)) {
                            if (!input.trySkipNullValue()) {
                                final QuestNavCommandType value = input.readEnum(QuestNavCommandType.converter());
                                if (value != null) {
                                    type = value.getNumber();
                                    bitField0_ |= 0x00000004;
                                } else {
                                    input.skipUnknownEnumValue();
                                }
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -305975184:
                    case -1565360272: {
                        if (input.isAtField(FieldNames.poseResetPayload)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(poseResetPayload);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clone() {
            return new ProtobufQuestNavCommand().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavCommand parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), data).checkInitialized();
        }

        public static ProtobufQuestNavCommand parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), input).checkInitialized();
        }

        public static ProtobufQuestNavCommand parseFrom(final JsonSource input) throws IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavCommand messages
         */
        public static MessageFactory<ProtobufQuestNavCommand> getFactory() {
            return ProtobufQuestNavCommandFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavCommand_descriptor;
        }

        private enum ProtobufQuestNavCommandFactory implements MessageFactory<ProtobufQuestNavCommand> {
            INSTANCE;

            @Override
            public ProtobufQuestNavCommand create() {
                return ProtobufQuestNavCommand.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName type = FieldName.forField("type");

            static final FieldName poseResetPayload = FieldName.forField("poseResetPayload", "pose_reset_payload");
        }
    }

    /**
     * <pre>
     * *
     *  Response message sent back after processing a command.
     *  
     *  This message is sent by the Quest back to the client after processing
     *  a ProtobufQuestNavCommand. It provides status information about whether
     *  the command was executed successfully and any error details if it failed.
     *  
     *  The response is matched to the original command using the command_id field,
     *  allowing for proper asynchronous command handling even when multiple
     *  commands are in flight simultaneously.
     *  
     *  Response Timing:
     *  - Responses are sent after command processing completes
     *  - Some commands may take time to execute (e.g., pose reset with validation)
     *  - Clients should implement timeouts for command responses
     *  
     *  Note: For FRC users, the vendor dependency will handle response matching automatically.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavCommandResponse}
     */
    public static final class ProtobufQuestNavCommandResponse extends ProtoMessage<ProtobufQuestNavCommandResponse> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         */
        private int commandId;

        /**
         * <pre>
         * *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         */
        private boolean success;

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         */
        private final Utf8String errorMessage = Utf8String.newEmptyInstance();

        private ProtobufQuestNavCommandResponse() {
        }

        /**
         * <pre>
         * *
         *  Response message sent back after processing a command.
         *  
         *  This message is sent by the Quest back to the client after processing
         *  a ProtobufQuestNavCommand. It provides status information about whether
         *  the command was executed successfully and any error details if it failed.
         *  
         *  The response is matched to the original command using the command_id field,
         *  allowing for proper asynchronous command handling even when multiple
         *  commands are in flight simultaneously.
         *  
         *  Response Timing:
         *  - Responses are sent after command processing completes
         *  - Some commands may take time to execute (e.g., pose reset with validation)
         *  - Clients should implement timeouts for command responses
         *  
         *  Note: For FRC users, the vendor dependency will handle response matching automatically.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavCommandResponse}
         */
        public static ProtobufQuestNavCommandResponse newInstance() {
            return new ProtobufQuestNavCommandResponse();
        }

        /**
         * <pre>
         * *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearCommandId() {
            bitField0_ &= ~0x00000001;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         * *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @param value the commandId to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setCommandId(final int value) {
            bitField0_ |= 0x00000001;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return whether the success field is set
         */
        public boolean hasSuccess() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearSuccess() {
            bitField0_ &= ~0x00000002;
            success = false;
            return this;
        }

        /**
         * <pre>
         * *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return the success
         */
        public boolean getSuccess() {
            return success;
        }

        /**
         * <pre>
         * *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @param value the success to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setSuccess(final boolean value) {
            bitField0_ |= 0x00000002;
            success = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return whether the errorMessage field is set
         */
        public boolean hasErrorMessage() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearErrorMessage() {
            bitField0_ &= ~0x00000004;
            errorMessage.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return the errorMessage
         */
        public String getErrorMessage() {
            return errorMessage.getString();
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for reading
         */
        public Utf8String getErrorMessageBytes() {
            return this.errorMessage;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for modifications
         */
        public Utf8String getMutableErrorMessageBytes() {
            bitField0_ |= 0x00000004;
            return this.errorMessage;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setErrorMessage(final CharSequence value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        /**
         * <pre>
         * *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setErrorMessage(final Utf8String value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse copyFrom(
                final ProtobufQuestNavCommandResponse other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                success = other.success;
                errorMessage.copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse mergeFrom(
                final ProtobufQuestNavCommandResponse other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasSuccess()) {
                setSuccess(other.success);
            }
            if (other.hasErrorMessage()) {
                getMutableErrorMessageBytes().copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            success = false;
            errorMessage.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            errorMessage.clear();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavCommandResponse)) {
                return false;
            }
            ProtobufQuestNavCommandResponse other = (ProtobufQuestNavCommandResponse) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasSuccess() || success == other.success)
                && (!hasErrorMessage() || errorMessage.equals(other.errorMessage));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeStringNoTag(errorMessage);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 2;
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeStringSizeNoTag(errorMessage);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavCommandResponse mergeFrom(final ProtoSource input) throws
                IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // success
                        success = input.readBool();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // errorMessage
                        input.readString(errorMessage);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeBool(FieldNames.success, success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeString(FieldNames.errorMessage, errorMessage);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavCommandResponse mergeFrom(final JsonSource input) throws
                IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -1867169789: {
                        if (input.isAtField(FieldNames.success)) {
                            if (!input.trySkipNullValue()) {
                                success = input.readBool();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 1203236063:
                    case -1938755376: {
                        if (input.isAtField(FieldNames.errorMessage)) {
                            if (!input.trySkipNullValue()) {
                                input.readString(errorMessage);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clone() {
            return new ProtobufQuestNavCommandResponse().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), data).checkInitialized();
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), input).checkInitialized();
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavCommandResponse messages
         */
        public static MessageFactory<ProtobufQuestNavCommandResponse> getFactory() {
            return ProtobufQuestNavCommandResponseFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavCommandResponse_descriptor;
        }

        private enum ProtobufQuestNavCommandResponseFactory implements MessageFactory<ProtobufQuestNavCommandResponse> {
            INSTANCE;

            @Override
            public ProtobufQuestNavCommandResponse create() {
                return ProtobufQuestNavCommandResponse.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName success = FieldName.forField("success");

            static final FieldName errorMessage = FieldName.forField("errorMessage", "error_message");
        }
    }
}
