// Code generated by protocol buffer compiler. Do not edit!
package gg.questnav.questnav.protos.generated;

import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.Utf8String;

public final class Commands {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(1940,
        "Cg5jb21tYW5kcy5wcm90bxIYcXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzGhBnZW9tZXRyeTJkLnByb3Rv" + 
        "Ik4KEFBvc2VSZXNldFBheWxvYWQSOgoLdGFyZ2V0X3Bvc2UYASABKAsyGS53cGkucHJvdG8uUHJvdG9i" + 
        "dWZQb3NlMmRSCnRhcmdldFBvc2UiygEKB0NvbW1hbmQSOQoEdHlwZRgBIAEoDjIlLnF1ZXN0bmF2LnBy" + 
        "b3Rvcy5jb21tYW5kcy5Db21tYW5kVHlwZVIEdHlwZRIdCgpjb21tYW5kX2lkGAIgASgNUgljb21tYW5k" + 
        "SWQSWgoScG9zZV9yZXNldF9wYXlsb2FkGAogASgLMioucXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzLlBv" + 
        "c2VSZXNldFBheWxvYWRIAFIQcG9zZVJlc2V0UGF5bG9hZEIJCgdwYXlsb2FkIm8KD0NvbW1hbmRSZXNw" + 
        "b25zZRIdCgpjb21tYW5kX2lkGAEgASgNUgljb21tYW5kSWQSGAoHc3VjY2VzcxgCIAEoCFIHc3VjY2Vz" + 
        "cxIjCg1lcnJvcl9tZXNzYWdlGAMgASgJUgxlcnJvck1lc3NhZ2UqOwoLQ29tbWFuZFR5cGUSHAoYQ09N" + 
        "TUFORF9UWVBFX1VOU1BFQ0lGSUVEEAASDgoKUE9TRV9SRVNFVBABQkMKJWdnLnF1ZXN0bmF2LnF1ZXN0" + 
        "bmF2LnByb3Rvcy5nZW5lcmF0ZWSqAhlRdWVzdE5hdi5Qcm90b3MuR2VuZXJhdGVkSr0KCgYSBAADMAEK" + 
        "CAoBDBIDAAMVCggKAQISAwIAIQoICgEIEgMDADYKCQoCCCUSAwMANgoICgEIEgMEAD4KCQoCCAESAwQA" + 
        "PgolCgIDABIDBwAaGhogSW1wb3J0IGdlb21ldHJ5IG1lc3NhZ2VzCgpFCgIFABIECgAOARo5IEVudW0g" + 
        "Zm9yIGNvbW1hbmQgdHlwZXMgKGV4dGVuc2libGUgZm9yIGZ1dHVyZSBjb21tYW5kcykKCgoKAwUAARID" + 
        "CgUQCi8KBAUAAgASAwsCHyIiIERlZmF1bHQgdmFsdWUgcmVxdWlyZWQgaW4gcHJvdG8zCgoMCgUFAAIA" + 
        "ARIDCwIaCgwKBQUAAgACEgMLHR4KLgoEBQACARIDDAIRIiEgUmVzZXQgcm9ib3QgcG9zZSB0byB0YXJn" + 
        "ZXQgcG9zZQoKDAoFBQACAQESAwwCDAoMCgUFAAIBAhIDDA8QCiwKAgQAEgQRABQBGiAgUGF5bG9hZCBm" + 
        "b3IgcG9zZSByZXNldCBjb21tYW5kCgoKCgMEAAESAxEIGApnCgQEAAIAEgMTAisaWiBUYXJnZXQgcG9z" + 
        "ZSBpbiBmaWVsZC1yZWxhdGl2ZSBXUElMaWIgY29vcmRpbmF0ZSBzcGFjZSAoeCBmb3J3YXJkLCB5IGxl" + 
        "ZnQsIHJvdGF0aW9uIENDVyspCgoMCgUEAAIABhIDEwIaCgwKBQQAAgABEgMTGyYKDAoFBAACAAMSAxMp" + 
        "KgoiCgIEARIEFwAkARoWIE1haW4gQ29tbWFuZCBtZXNzYWdlCgoKCgMEAQESAxcIDwoiCgQEAQIAEgMZ",
        "AhcaFSBUaGUgdHlwZSBvZiBjb21tYW5kCgoMCgUEAQIABhIDGQINCgwKBQQBAgABEgMZDhIKDAoFBAEC" + 
        "AAMSAxkVFgowCgQEAQIBEgMcAhgaIyBDb21tYW5kIElEIGZvciB0cmFja2luZy9yZXNwb25zZXMKCgwK" + 
        "BQQBAgEFEgMcAggKDAoFBAECAQESAxwJEwoMCgUEAQIBAxIDHBYXClUKBAQBCAASBB8CIwMaRyBDb21t" + 
        "YW5kLXNwZWNpZmljIHBheWxvYWQgKG9ubHkgb25lIHdpbGwgYmUgc2V0IGJhc2VkIG9uIGNvbW1hbmQg" + 
        "dHlwZSkKCgwKBQQBCAABEgMfCA8KYQoEBAECAhIDIAQtIlQgRnV0dXJlIHBheWxvYWRzIGNhbiBiZSBh" + 
        "ZGRlZCBoZXJlOgogKENvbW1hbmRzIHdpdGggbm8gcGF5bG9hZCBkb24ndCBuZWVkIGFuIGVudHJ5KQoK" + 
        "DAoFBAECAgYSAyAEFAoMCgUEAQICARIDIBUnCgwKBQQBAgIDEgMgKiwKKwoCBAISBCcAMAEaHyBSZXNw" + 
        "b25zZSBtZXNzYWdlIGZvciBjb21tYW5kcwoKCgoDBAIBEgMnCBcKLgoEBAICABIDKQIYGiEgTWF0Y2hl" + 
        "cyB0aGUgb3JpZ2luYWwgY29tbWFuZCBJRAoKDAoFBAICAAUSAykCCAoMCgUEAgIAARIDKQkTCgwKBQQC" + 
        "AgADEgMpFhcKMQoEBAICARIDLAITGiQgV2hldGhlciB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bAoK" + 
        "DAoFBAICAQUSAywCBgoMCgUEAgIBARIDLAcOCgwKBQQCAgEDEgMsERIKLwoEBAICAhIDLwIbGiIgRXJy" + 
        "b3IgbWVzc2FnZSBpZiBzdWNjZXNzID0gZmFsc2UKCgwKBQQCAgIFEgMvAggKDAoFBAICAgESAy8JFgoM" + 
        "CgUEAgICAxIDLxkaYgZwcm90bzM=");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("commands.proto", "questnav.protos.commands", descriptorData, Geometry2D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_commands_PoseResetPayload_descriptor = descriptor.internalContainedType(62, 78, "PoseResetPayload", "questnav.protos.commands.PoseResetPayload");

    static final Descriptors.Descriptor questnav_protos_commands_Command_descriptor = descriptor.internalContainedType(143, 202, "Command", "questnav.protos.commands.Command");

    static final Descriptors.Descriptor questnav_protos_commands_CommandResponse_descriptor = descriptor.internalContainedType(347, 111, "CommandResponse", "questnav.protos.commands.CommandResponse");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     *  Enum for command types (extensible for future commands)
     * </pre>
     *
     * Protobuf enum {@code CommandType}
     */
    public enum CommandType implements ProtoEnum<CommandType> {
        /**
         * <pre>
         *  Default value required in proto3
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        COMMAND_TYPE_UNSPECIFIED("COMMAND_TYPE_UNSPECIFIED", 0),

        /**
         * <pre>
         *  Reset robot pose to target pose
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        POSE_RESET("POSE_RESET", 1);

        /**
         * <pre>
         *  Default value required in proto3
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        public static final int COMMAND_TYPE_UNSPECIFIED_VALUE = 0;

        /**
         * <pre>
         *  Reset robot pose to target pose
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        public static final int POSE_RESET_VALUE = 1;

        private final String name;

        private final int number;

        private CommandType(String name, int number) {
            this.name = name;
            this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
            return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
            return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<CommandType> converter() {
            return CommandTypeConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static CommandType forNumber(int value) {
            return CommandTypeConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static CommandType forNumberOr(int number, CommandType other) {
            CommandType value = forNumber(number);
            return value == null ? other : value;
        }

        enum CommandTypeConverter implements ProtoEnum.EnumConverter<CommandType> {
            INSTANCE;

            private static final CommandType[] lookup = new CommandType[2];

            static {
                lookup[0] = COMMAND_TYPE_UNSPECIFIED;
                lookup[1] = POSE_RESET;
            }

            @Override
            public final CommandType forNumber(final int value) {
                if (value >= 0 && value < lookup.length) {
                    return lookup[value];
                }
                return null;
            }

            @Override
            public final CommandType forName(final CharSequence value) {
                if (value.length() == 10) {
                    if (ProtoUtil.isEqual("POSE_RESET", value)) {
                        return POSE_RESET;
                    }
                }
                if (value.length() == 24) {
                    if (ProtoUtil.isEqual("COMMAND_TYPE_UNSPECIFIED", value)) {
                        return COMMAND_TYPE_UNSPECIFIED;
                    }
                }
                return null;
            }
        }
    }

    /**
     * <pre>
     *  Payload for pose reset command
     * </pre>
     *
     * Protobuf type {@code PoseResetPayload}
     */
    public static final class PoseResetPayload extends ProtoMessage<PoseResetPayload> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         */
        private final Geometry2D.ProtobufPose2d targetPose = Geometry2D.ProtobufPose2d.newInstance();

        private PoseResetPayload() {
        }

        /**
         * <pre>
         *  Payload for pose reset command
         * </pre>
         *
         * @return a new empty instance of {@code PoseResetPayload}
         */
        public static PoseResetPayload newInstance() {
            return new PoseResetPayload();
        }

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @return whether the targetPose field is set
         */
        public boolean hasTargetPose() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @return this
         */
        public PoseResetPayload clearTargetPose() {
            bitField0_ &= ~0x00000001;
            targetPose.clear();
            return this;
        }

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutableTargetPose()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry2D.ProtobufPose2d getTargetPose() {
            return targetPose;
        }

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry2D.ProtobufPose2d getMutableTargetPose() {
            bitField0_ |= 0x00000001;
            return targetPose;
        }

        /**
         * <pre>
         *  Target pose in field-relative WPILib coordinate space (x forward, y left, rotation CCW+)
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d target_pose = 1;</code>
         * @param value the targetPose to set
         * @return this
         */
        public PoseResetPayload setTargetPose(final Geometry2D.ProtobufPose2d value) {
            bitField0_ |= 0x00000001;
            targetPose.copyFrom(value);
            return this;
        }

        @Override
        public PoseResetPayload copyFrom(final PoseResetPayload other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                targetPose.copyFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public PoseResetPayload mergeFrom(final PoseResetPayload other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTargetPose()) {
                getMutableTargetPose().mergeFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public PoseResetPayload clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clear();
            return this;
        }

        @Override
        public PoseResetPayload clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof PoseResetPayload)) {
                return false;
            }
            PoseResetPayload other = (PoseResetPayload) o;
            return bitField0_ == other.bitField0_
                && (!hasTargetPose() || targetPose.equals(other.targetPose));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 10);
                output.writeMessageNoTag(targetPose);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(targetPose);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public PoseResetPayload mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 10: {
                        // targetPose
                        input.readMessage(targetPose);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.targetPose, targetPose);
            }
            output.endObject();
        }

        @Override
        public PoseResetPayload mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 486493634:
                    case -2084687233: {
                        if (input.isAtField(FieldNames.targetPose)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(targetPose);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public PoseResetPayload clone() {
            return new PoseResetPayload().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static PoseResetPayload parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new PoseResetPayload(), data).checkInitialized();
        }

        public static PoseResetPayload parseFrom(final ProtoSource input) throws IOException {
            return ProtoMessage.mergeFrom(new PoseResetPayload(), input).checkInitialized();
        }

        public static PoseResetPayload parseFrom(final JsonSource input) throws IOException {
            return ProtoMessage.mergeFrom(new PoseResetPayload(), input).checkInitialized();
        }

        /**
         * @return factory for creating PoseResetPayload messages
         */
        public static MessageFactory<PoseResetPayload> getFactory() {
            return PoseResetPayloadFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_PoseResetPayload_descriptor;
        }

        private enum PoseResetPayloadFactory implements MessageFactory<PoseResetPayload> {
            INSTANCE;

            @Override
            public PoseResetPayload create() {
                return PoseResetPayload.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName targetPose = FieldName.forField("targetPose", "target_pose");
        }
    }

    /**
     * <pre>
     *  Main Command message
     * </pre>
     *
     * Protobuf type {@code Command}
     */
    public static final class Command extends ProtoMessage<Command> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *  Command ID for tracking/responses
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         */
        private int commandId;

        /**
         * <pre>
         *  The type of command
         * </pre>
         *
         * <code>optional .questnav.protos.commands.CommandType type = 1;</code>
         */
        private int type;

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         */
        private final PoseResetPayload poseResetPayload = PoseResetPayload.newInstance();

        private Command() {
        }

        /**
         * <pre>
         *  Main Command message
         * </pre>
         *
         * @return a new empty instance of {@code Command}
         */
        public static Command newInstance() {
            return new Command();
        }

        public boolean hasPayload() {
            return (((bitField0_ & 0x00000001)) != 0);
        }

        public Command clearPayload() {
            if (hasPayload()) {
                clearPoseResetPayload();
            }
            return this;
        }

        /**
         * <pre>
         *  Command ID for tracking/responses
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *  Command ID for tracking/responses
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return this
         */
        public Command clearCommandId() {
            bitField0_ &= ~0x00000002;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         *  Command ID for tracking/responses
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         *  Command ID for tracking/responses
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @param value the commandId to set
         * @return this
         */
        public Command setCommandId(final int value) {
            bitField0_ |= 0x00000002;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         *  The type of command
         * </pre>
         *
         * <code>optional .questnav.protos.commands.CommandType type = 1;</code>
         * @return whether the type field is set
         */
        public boolean hasType() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *  The type of command
         * </pre>
         *
         * <code>optional .questnav.protos.commands.CommandType type = 1;</code>
         * @return this
         */
        public Command clearType() {
            bitField0_ &= ~0x00000004;
            type = 0;
            return this;
        }

        /**
         * <pre>
         *  The type of command
         * </pre>
         *
         * <code>optional .questnav.protos.commands.CommandType type = 1;</code>
         * @return the type
         */
        public CommandType getType() {
            return CommandType.forNumber(type);
        }

        /**
         * Gets the value of the internal enum store. The result is
         * equivalent to {@link Command#getType()}.getNumber().
         *
         * @return numeric wire representation
         */
        public int getTypeValue() {
            return type;
        }

        /**
         * Sets the value of the internal enum store. This does not
         * do any validity checks, so be sure to use appropriate value
         * constants from {@link CommandType}. Setting an invalid value
         * can cause {@link Command#getType()} to return null
         *
         * @param value the numeric wire value to set
         * @return this
         */
        public Command setTypeValue(final int value) {
            bitField0_ |= 0x00000004;
            type = value;
            return this;
        }

        /**
         * <pre>
         *  The type of command
         * </pre>
         *
         * <code>optional .questnav.protos.commands.CommandType type = 1;</code>
         * @param value the type to set
         * @return this
         */
        public Command setType(final CommandType value) {
            bitField0_ |= 0x00000004;
            type = value.getNumber();
            return this;
        }

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         * @return whether the poseResetPayload field is set
         */
        public boolean hasPoseResetPayload() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         * @return this
         */
        public Command clearPoseResetPayload() {
            bitField0_ &= ~0x00000001;
            poseResetPayload.clear();
            return this;
        }

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePoseResetPayload()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public PoseResetPayload getPoseResetPayload() {
            return poseResetPayload;
        }

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public PoseResetPayload getMutablePoseResetPayload() {
            bitField0_ |= 0x00000001;
            return poseResetPayload;
        }

        /**
         * <pre>
         *  Future payloads can be added here:
         *  (Commands with no payload don't need an entry)
         * </pre>
         *
         * <code>optional .questnav.protos.commands.PoseResetPayload pose_reset_payload = 10;</code>
         * @param value the poseResetPayload to set
         * @return this
         */
        public Command setPoseResetPayload(final PoseResetPayload value) {
            bitField0_ |= 0x00000001;
            poseResetPayload.copyFrom(value);
            return this;
        }

        @Override
        public Command copyFrom(final Command other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                type = other.type;
                poseResetPayload.copyFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public Command mergeFrom(final Command other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasType()) {
                setTypeValue(other.type);
            }
            if (other.hasPoseResetPayload()) {
                getMutablePoseResetPayload().mergeFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public Command clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            type = 0;
            poseResetPayload.clear();
            return this;
        }

        @Override
        public Command clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            poseResetPayload.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof Command)) {
                return false;
            }
            Command other = (Command) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasType() || type == other.type)
                && (!hasPoseResetPayload() || poseResetPayload.equals(other.poseResetPayload));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 8);
                output.writeEnumNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 82);
                output.writeMessageNoTag(poseResetPayload);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeEnumSizeNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(poseResetPayload);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public Command mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 16: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // type
                        final int value = input.readInt32();
                        if (CommandType.forNumber(value) != null) {
                            type = value;
                            bitField0_ |= 0x00000004;
                        }
                        tag = input.readTag();
                        if (tag != 82) {
                            break;
                        }
                    }
                    case 82: {
                        // poseResetPayload
                        input.readMessage(poseResetPayload);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeEnum(FieldNames.type, type, CommandType.converter());
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.poseResetPayload, poseResetPayload);
            }
            output.endObject();
        }

        @Override
        public Command mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 3575610: {
                        if (input.isAtField(FieldNames.type)) {
                            if (!input.trySkipNullValue()) {
                                final CommandType value = input.readEnum(CommandType.converter());
                                if (value != null) {
                                    type = value.getNumber();
                                    bitField0_ |= 0x00000004;
                                } else {
                                    input.skipUnknownEnumValue();
                                }
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -305975184:
                    case -1565360272: {
                        if (input.isAtField(FieldNames.poseResetPayload)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(poseResetPayload);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public Command clone() {
            return new Command().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static Command parseFrom(final byte[] data) throws InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new Command(), data).checkInitialized();
        }

        public static Command parseFrom(final ProtoSource input) throws IOException {
            return ProtoMessage.mergeFrom(new Command(), input).checkInitialized();
        }

        public static Command parseFrom(final JsonSource input) throws IOException {
            return ProtoMessage.mergeFrom(new Command(), input).checkInitialized();
        }

        /**
         * @return factory for creating Command messages
         */
        public static MessageFactory<Command> getFactory() {
            return CommandFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_Command_descriptor;
        }

        private enum CommandFactory implements MessageFactory<Command> {
            INSTANCE;

            @Override
            public Command create() {
                return Command.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName type = FieldName.forField("type");

            static final FieldName poseResetPayload = FieldName.forField("poseResetPayload", "pose_reset_payload");
        }
    }

    /**
     * <pre>
     *  Response message for commands
     * </pre>
     *
     * Protobuf type {@code CommandResponse}
     */
    public static final class CommandResponse extends ProtoMessage<CommandResponse> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *  Matches the original command ID
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         */
        private int commandId;

        /**
         * <pre>
         *  Whether the command was successful
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         */
        private boolean success;

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         */
        private final Utf8String errorMessage = Utf8String.newEmptyInstance();

        private CommandResponse() {
        }

        /**
         * <pre>
         *  Response message for commands
         * </pre>
         *
         * @return a new empty instance of {@code CommandResponse}
         */
        public static CommandResponse newInstance() {
            return new CommandResponse();
        }

        /**
         * <pre>
         *  Matches the original command ID
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *  Matches the original command ID
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return this
         */
        public CommandResponse clearCommandId() {
            bitField0_ &= ~0x00000001;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         *  Matches the original command ID
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         *  Matches the original command ID
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @param value the commandId to set
         * @return this
         */
        public CommandResponse setCommandId(final int value) {
            bitField0_ |= 0x00000001;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         *  Whether the command was successful
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return whether the success field is set
         */
        public boolean hasSuccess() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *  Whether the command was successful
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return this
         */
        public CommandResponse clearSuccess() {
            bitField0_ &= ~0x00000002;
            success = false;
            return this;
        }

        /**
         * <pre>
         *  Whether the command was successful
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return the success
         */
        public boolean getSuccess() {
            return success;
        }

        /**
         * <pre>
         *  Whether the command was successful
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @param value the success to set
         * @return this
         */
        public CommandResponse setSuccess(final boolean value) {
            bitField0_ |= 0x00000002;
            success = value;
            return this;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return whether the errorMessage field is set
         */
        public boolean hasErrorMessage() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return this
         */
        public CommandResponse clearErrorMessage() {
            bitField0_ &= ~0x00000004;
            errorMessage.clear();
            return this;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return the errorMessage
         */
        public String getErrorMessage() {
            return errorMessage.getString();
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for reading
         */
        public Utf8String getErrorMessageBytes() {
            return this.errorMessage;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for modifications
         */
        public Utf8String getMutableErrorMessageBytes() {
            bitField0_ |= 0x00000004;
            return this.errorMessage;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public CommandResponse setErrorMessage(final CharSequence value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        /**
         * <pre>
         *  Error message if success = false
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public CommandResponse setErrorMessage(final Utf8String value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        @Override
        public CommandResponse copyFrom(final CommandResponse other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                success = other.success;
                errorMessage.copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public CommandResponse mergeFrom(final CommandResponse other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasSuccess()) {
                setSuccess(other.success);
            }
            if (other.hasErrorMessage()) {
                getMutableErrorMessageBytes().copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public CommandResponse clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            success = false;
            errorMessage.clear();
            return this;
        }

        @Override
        public CommandResponse clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            errorMessage.clear();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof CommandResponse)) {
                return false;
            }
            CommandResponse other = (CommandResponse) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasSuccess() || success == other.success)
                && (!hasErrorMessage() || errorMessage.equals(other.errorMessage));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeStringNoTag(errorMessage);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 2;
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeStringSizeNoTag(errorMessage);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public CommandResponse mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // success
                        success = input.readBool();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // errorMessage
                        input.readString(errorMessage);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeBool(FieldNames.success, success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeString(FieldNames.errorMessage, errorMessage);
            }
            output.endObject();
        }

        @Override
        public CommandResponse mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -1867169789: {
                        if (input.isAtField(FieldNames.success)) {
                            if (!input.trySkipNullValue()) {
                                success = input.readBool();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 1203236063:
                    case -1938755376: {
                        if (input.isAtField(FieldNames.errorMessage)) {
                            if (!input.trySkipNullValue()) {
                                input.readString(errorMessage);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public CommandResponse clone() {
            return new CommandResponse().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static CommandResponse parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new CommandResponse(), data).checkInitialized();
        }

        public static CommandResponse parseFrom(final ProtoSource input) throws IOException {
            return ProtoMessage.mergeFrom(new CommandResponse(), input).checkInitialized();
        }

        public static CommandResponse parseFrom(final JsonSource input) throws IOException {
            return ProtoMessage.mergeFrom(new CommandResponse(), input).checkInitialized();
        }

        /**
         * @return factory for creating CommandResponse messages
         */
        public static MessageFactory<CommandResponse> getFactory() {
            return CommandResponseFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_CommandResponse_descriptor;
        }

        private enum CommandResponseFactory implements MessageFactory<CommandResponse> {
            INSTANCE;

            @Override
            public CommandResponse create() {
                return CommandResponse.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName success = FieldName.forField("success");

            static final FieldName errorMessage = FieldName.forField("errorMessage", "error_message");
        }
    }
}
