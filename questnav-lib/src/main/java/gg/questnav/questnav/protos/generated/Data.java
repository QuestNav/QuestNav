// Code generated by protocol buffer compiler. Do not edit!
package gg.questnav.questnav.protos.generated;

import edu.wpi.first.math.proto.Geometry2D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;

public final class Data {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(6841,
        "CgpkYXRhLnByb3RvEhRxdWVzdG5hdi5wcm90b3MuZGF0YRoQZ2VvbWV0cnkyZC5wcm90byKNAQoZUHJv" + 
        "dG9idWZRdWVzdE5hdkZyYW1lRGF0YRIfCgtmcmFtZV9jb3VudBgBIAEoBVIKZnJhbWVDb3VudBIcCgl0" + 
        "aW1lc3RhbXAYAiABKAFSCXRpbWVzdGFtcBIxCgZwb3NlMmQYAyABKAsyGS53cGkucHJvdG8uUHJvdG9i" + 
        "dWZQb3NlMmRSBnBvc2UyZCKoAQoaUHJvdG9idWZRdWVzdE5hdkRldmljZURhdGESMgoVdHJhY2tpbmdf" + 
        "bG9zdF9jb3VudGVyGAEgASgFUhN0cmFja2luZ0xvc3RDb3VudGVyEi0KEmN1cnJlbnRseV90cmFja2lu" + 
        "ZxgCIAEoCFIRY3VycmVudGx5VHJhY2tpbmcSJwoPYmF0dGVyeV9wZXJjZW50GAMgASgFUg5iYXR0ZXJ5" + 
        "UGVyY2VudEJDCiVnZy5xdWVzdG5hdi5xdWVzdG5hdi5wcm90b3MuZ2VuZXJhdGVkqgIZUXVlc3ROYXYu" + 
        "UHJvdG9zLkdlbmVyYXRlZEr6MQoHEgUAA70BAQoICgEMEgMAAxUK5AYKAQISAxYAHTLZBioKIFF1ZXN0" + 
        "TmF2IERhdGEgUHJvdG9jb2wgQnVmZmVyIERlZmluaXRpb25zCiAKIFRoaXMgZmlsZSBkZWZpbmVzIHRo" + 
        "ZSBkYXRhIHN0cnVjdHVyZXMgdXNlZCBmb3IgdHJhbnNtaXR0aW5nIHRyYWNraW5nIGFuZCBkZXZpY2UK" + 
        "IGluZm9ybWF0aW9uIGZyb20gdGhlIFF1ZXN0IGhlYWRzZXQgdG8gZXh0ZXJuYWwgc3lzdGVtcyAoc3Vj" + 
        "aCBhcyByb2JvdCBjb2RlKS4KIFRoZSBkYXRhIGlzIG9yZ2FuaXplZCBpbnRvIHR3byBtYWluIGNhdGVn" + 
        "b3JpZXMgd2l0aCBkaWZmZXJlbnQgdXBkYXRlIGZyZXF1ZW5jaWVzOgogCiAxLiBGcmFtZSBEYXRhOiBI" + 
        "aWdoLWZyZXF1ZW5jeSB0cmFja2luZyBpbmZvcm1hdGlvbiAocG9zZSwgdGltZXN0YW1wcykKIDIuIERl" + 
        "dmljZSBEYXRhOiBMb3dlci1mcmVxdWVuY3kgZGV2aWNlIHN0YXR1cyBpbmZvcm1hdGlvbiAoYmF0dGVy" + 
        "eSwgdHJhY2tpbmcgc3RhdGUpCiAKIFRoaXMgc2VwYXJhdGlvbiBhbGxvd3MgZm9yIGVmZmljaWVudCBi" + 
        "YW5kd2lkdGggdXNhZ2UgYnkgc2VuZGluZyBjcml0aWNhbCB0cmFja2luZwogZGF0YSBmcmVxdWVudGx5" + 
        "IHdoaWxlIHNlbmRpbmcgbGVzcyBjcml0aWNhbCBkZXZpY2Ugc3RhdHVzIGRhdGEgYXQgYSBsb3dlciBy" + 
        "YXRlLgogCiBEYXRhIEZsb3c6CiAtIFF1ZXN0IGNvbnRpbnVvdXNseSBwcm9jZXNzZXMgY2FtZXJhL3Nl" + 
        "bnNvciBkYXRhCiAtIEZyYW1lIGRhdGEgaXMgc2VudCBldmVyeSAxMCBtaWxsaXNlY29uZHMgKDEwMCBI",
        "eikKIC0gRGV2aWNlIGRhdGEgaXMgc2VudCBldmVyeSAzMzMgbWlsbGlzZWNvbmRzICgzIEh6KQogLSBF" + 
        "eHRlcm5hbCBzeXN0ZW1zIHJlY2VpdmUgYW5kIHByb2Nlc3MgdGhpcyBkYXRhIGZvciByb2JvdCBsb2Nh" + 
        "bGl6YXRpb24KCggKAQgSAxcANgoJCgIIJRIDFwA2CggKAQgSAxgAPgoJCgIIARIDGAA+Cj0KAgMAEgMb" + 
        "ABoaMiBJbXBvcnQgZ2VvbWV0cnkgbWVzc2FnZXMgZm9yIHBvc2UgcmVwcmVzZW50YXRpb24KCsAFCgIE" + 
        "ABIELQBmARqzBSoKIEhpZ2gtZnJlcXVlbmN5IHRyYWNraW5nIGRhdGEgc2VudCBmcm9tIFF1ZXN0IHRv" + 
        "IGV4dGVybmFsIHN5c3RlbXMuCiAKIFRoaXMgbWVzc2FnZSBjb250YWlucyB0aGUgY29yZSB0cmFja2lu" + 
        "ZyBpbmZvcm1hdGlvbiB0aGF0IGV4dGVybmFsIHN5c3RlbXMKIChsaWtlIHJvYm90IGNvZGUpIG5lZWQg" + 
        "Zm9yIHJlYWwtdGltZSBsb2NhbGl6YXRpb24gYW5kIG5hdmlnYXRpb24uIEl0J3Mgc2VudAogYXQgMTAw" + 
        "IEh6IChldmVyeSAxMCBtaWxsaXNlY29uZHMpIHRvIHByb3ZpZGUgc21vb3RoLCByZXNwb25zaXZlIHRy" + 
        "YWNraW5nLgogCiBUaGUgZGF0YSByZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uIGFuZCBvcmll" + 
        "bnRhdGlvbiBvbiB0aGUgZmllbGQsCiBkZXJpdmVkIGZyb20gdmlzdWFsLWluZXJ0aWFsIG9kb21ldHJ5" + 
        "IHVzaW5nIHRoZSBRdWVzdCdzIGNhbWVyYXMgYW5kIElNVSBzZW5zb3JzLgogCiBDb29yZGluYXRlIFN5" + 
        "c3RlbToKIC0gVXNlcyBXUElMaWIgZmllbGQtcmVsYXRpdmUgY29vcmRpbmF0ZSBzeXN0ZW0KIC0gT3Jp" + 
        "Z2luIGFuZCBheGVzIGRlcGVuZCBvbiBmaWVsZCBzZXR1cCBhbmQgY2FsaWJyYXRpb24KIC0gUG9zZSBy" + 
        "ZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uOyBtb3VudGluZyBvZmZzZXQgdG8gZ2V0IHJvYm90" + 
        "IHBvc2l0aW9uCiAgIGlzIGFwcGxpZWQgaW4gZW5kIHVzZXIgY29kZQoKCgoDBAABEgMtCCEKuAMKBAQA" + 
        "AgASAzsCGBqqAyoKIFNlcXVlbnRpYWwgZnJhbWUgY291bnRlciBmb3IgdGhpcyB0cmFja2luZyBzZXNz" + 
        "aW9uLgogCiBUaGlzIGNvdW50ZXIgaW5jcmVtZW50cyB3aXRoIGVhY2ggZnJhbWUgcHJvY2Vzc2VkIGJ5" + 
        "IHRoZSBRdWVzdCdzIHRyYWNraW5nCiBzeXN0ZW0uIEl0IGNhbiBiZSB1c2VkIHRvOgogLSBEZXRlY3Qg" + 
        "ZHJvcHBlZCBtZXNzYWdlcwogLSBDYWxjdWxhdGUgZWZmZWN0aXZlIGZyYW1lIHJhdGUKIC0gU3luY2hy",
        "b25pemUgd2l0aCBvdGhlciBkYXRhIHN0cmVhbXMKIAogVGhlIGNvdW50ZXIgcmVzZXRzIHRvIDAgd2hl" + 
        "biB0aGUgUXVlc3ROYXYgYXBwIHN0YXJ0cyBhbmQgaW5jcmVtZW50cwogY29udGludW91c2x5IGR1cmlu" + 
        "ZyBvcGVyYXRpb24uIEZyYW1lIGRyb3BzIGluIHRyYW5zbWlzc2lvbiB3aWxsIGNyZWF0ZQogZ2FwcyBp" + 
        "biB0aGUgc2VxdWVuY2UuCgoMCgUEAAIABRIDOwIHCgwKBQQAAgABEgM7CBMKDAoFBAACAAMSAzsWFwrf" + 
        "AwoEBAACARIDTAIXGtEDKgogVGltZXN0YW1wIGluIHNlY29uZHMgc2luY2UgUXVlc3ROYXYgYXBwIHN0" + 
        "YXJ0dXAuCiAKIFRoaXMgcHJvdmlkZXMgdGltaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgdHJhY2tpbmcg" + 
        "ZGF0YSwgYWxsb3dpbmcgZXh0ZXJuYWwKIHN5c3RlbXMgdG86CiAtIENhbGN1bGF0ZSBkYXRhIGFnZSBh" + 
        "bmQgbGF0ZW5jeQogLSBJbnRlcnBvbGF0ZSBvciBleHRyYXBvbGF0ZSBwb3NlcyBmb3IgcHJlZGljdGlv" + 
        "bgogLSBTeW5jaHJvbml6ZSB3aXRoIG90aGVyIHNlbnNvciBkYXRhCiAtIEltcGxlbWVudCB0aW1lb3V0" + 
        "IGRldGVjdGlvbgogCiBUaGUgdGltZXN0YW1wIGlzIHJlbGF0aXZlIHRvIGFwcCBzdGFydHVwLCBub3Qg" + 
        "c3lzdGVtIHRpbWUsIHRvIGF2b2lkCiBjbG9jayBzeW5jaHJvbml6YXRpb24gaXNzdWVzIGJldHdlZW4g" + 
        "ZGV2aWNlcy4KIAogUmVzb2x1dGlvbjogVHlwaWNhbGx5IHN1Yi1taWxsaXNlY29uZCBwcmVjaXNpb24K" + 
        "CgwKBQQAAgEFEgNMAggKDAoFBAACAQESA0wJEgoMCgUEAAIBAxIDTBUWCv8FCgQEAAICEgNlAiYa8QUq" + 
        "CiBRdWVzdCdzIDJEIHBvc2Ugb24gdGhlIGZpZWxkIGluIFdQSUxpYiBjb29yZGluYXRlcy4KIAogVGhp" + 
        "cyByZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBhcyBkZXRlcm1p" + 
        "bmVkIGJ5CiB0aGUgUXVlc3QncyB0cmFja2luZyBzeXN0ZW0uIFRoZSBwb3NlIGFjY291bnRzIGZvcjoK" + 
        "IC0gQ29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb24gdG8gV1BJTGliIHN0YW5kYXJkCiAtIEFu" + 
        "eSBjYWxpYnJhdGlvbiBvZmZzZXRzIGFwcGxpZWQKIAogTm90ZTogVGhpcyBpcyB0aGUgUXVlc3QncyBw" + 
        "b3NpdGlvbjsgZW5kIHVzZXIgY29kZSBhcHBsaWVzIG1vdW50aW5nIG9mZnNldAogdG8gZ2V0IHRoZSBy" + 
        "b2JvdCdzIHBvc2l0aW9uLgogCiBDb29yZGluYXRlIFN5c3RlbSBEZXRhaWxzOgogLSBYOiBGb3J3YXJk",
        "IGRpcmVjdGlvbiAodG93YXJkcyBvcHBvc2luZyBhbGxpYW5jZSkKIC0gWTogTGVmdCBkaXJlY3Rpb24g" + 
        "KHdoZW4gZmFjaW5nIGZvcndhcmQpICAKIC0gUm90YXRpb246IENvdW50ZXItY2xvY2t3aXNlIHBvc2l0" + 
        "aXZlIChyYWRpYW5zKQogLSBVbml0czogbWV0ZXJzIGZvciB0cmFuc2xhdGlvbiwgcmFkaWFucyBmb3Ig" + 
        "cm90YXRpb24KIAogQWNjdXJhY3kgZGVwZW5kcyBvbjoKIC0gRW52aXJvbm1lbnRhbCBsaWdodGluZyBh" + 
        "bmQgZmVhdHVyZXMKIC0gUXVlc3QgdHJhY2tpbmcgcXVhbGl0eQogLSBDYWxpYnJhdGlvbiBhY2N1cmFj" + 
        "eQogLSBUaW1lIHNpbmNlIGxhc3QgcG9zZSByZXNldAoKDAoFBAACAgYSA2UCGgoMCgUEAAICARIDZRsh" + 
        "CgwKBQQAAgIDEgNlJCUK8gQKAgQBEgV5AL0BARrkBCoKIExvd2VyLWZyZXF1ZW5jeSBkZXZpY2Ugc3Rh" + 
        "dHVzIGRhdGEgc2VudCBmcm9tIFF1ZXN0IHRvIGV4dGVybmFsIHN5c3RlbXMuCiAKIFRoaXMgbWVzc2Fn" + 
        "ZSBjb250YWlucyBkZXZpY2UgaGVhbHRoIGFuZCBzdGF0dXMgaW5mb3JtYXRpb24gdGhhdCBkb2Vzbid0" + 
        "IG5lZWQKIHRvIGJlIHNlbnQgYXMgZnJlcXVlbnRseSBhcyB0cmFja2luZyBkYXRhLiBJdCdzIHNlbnQg" + 
        "YXQgMyBIeiAoZXZlcnkgMzMzIG1pbGxpc2Vjb25kcykKIHRvIHByb3ZpZGUgbW9uaXRvcmluZyBhbmQg" + 
        "ZGlhZ25vc3RpYyBpbmZvcm1hdGlvbiB3aXRob3V0IGNvbnN1bWluZyBleGNlc3NpdmUKIGJhbmR3aWR0" + 
        "aC4KIAogVGhpcyBkYXRhIGhlbHBzIGV4dGVybmFsIHN5c3RlbXM6CiAtIE1vbml0b3IgUXVlc3QgZGV2" + 
        "aWNlIGhlYWx0aAogLSBEZXRlY3QgdHJhY2tpbmcgc3lzdGVtIGlzc3VlcwogLSBJbXBsZW1lbnQgZmFp" + 
        "bHNhZmUgYmVoYXZpb3JzCiAtIFByb3ZpZGUgdXNlciBmZWVkYmFjayBhYm91dCBzeXN0ZW0gc3RhdHVz" + 
        "CiAKIFRoZSBpbmZvcm1hdGlvbiBpcyB1c2VmdWwgZm9yIGJvdGggYXV0b25vbW91cyBvcGVyYXRpb24g" + 
        "YW5kIGRlYnVnZ2luZy8KIHRyb3VibGVzaG9vdGluZyBzY2VuYXJpb3MuCgoKCgMEAQESA3kIIgqGBQoE" + 
        "BAECABIEjQECIhr3BCoKIENvdW50IG9mIHRyYWNraW5nIGxvc3MgZXZlbnRzIHNpbmNlIGFwcCBzdGFy" + 
        "dHVwLgogCiBUaGlzIGNvdW50ZXIgaW5jcmVtZW50cyBlYWNoIHRpbWUgdGhlIFF1ZXN0J3MgdHJhY2tp" + 
        "bmcgc3lzdGVtIGxvc2VzCiB0cmFja2luZyBhZnRlciBoYXZpbmcgZXN0YWJsaXNoZWQgaXQuIFRyYWNr",
        "aW5nIGxvc3MgY2FuIG9jY3VyIGR1ZSB0bzoKIC0gUG9vciBsaWdodGluZyBjb25kaXRpb25zCiAtIExh" + 
        "Y2sgb2YgdmlzdWFsIGZlYXR1cmVzIGluIGVudmlyb25tZW50CiAtIFJhcGlkIG1vdGlvbiBvciBhY2Nl" + 
        "bGVyYXRpb24KIC0gT2NjbHVzaW9uIG9mIGNhbWVyYXMKIC0gSGFyZHdhcmUgaXNzdWVzCiAKIEEgaGln" + 
        "aCBvciByYXBpZGx5IGluY3JlYXNpbmcgY291bnRlciBtYXkgaW5kaWNhdGU6CiAtIEVudmlyb25tZW50" + 
        "YWwgaXNzdWVzIChsaWdodGluZywgZmVhdHVyZXMpCiAtIFF1ZXN0IG1vdW50aW5nIHByb2JsZW1zICh2" + 
        "aWJyYXRpb24sIG9ic3RydWN0aW9uKQogLSBIYXJkd2FyZSBkZWdyYWRhdGlvbgogCiBUaGlzIG1ldHJp" + 
        "YyBoZWxwcyBhc3Nlc3MgdHJhY2tpbmcgc3lzdGVtIHJlbGlhYmlsaXR5IGFuZCBjYW4gdHJpZ2dlcgog" + 
        "YWxlcnRzIG9yIGZhbGxiYWNrIGJlaGF2aW9ycyBpbiByb2JvdCBjb2RlLgoKDQoFBAECAAUSBI0BAgcK" + 
        "DQoFBAECAAESBI0BCB0KDQoFBAECAAMSBI0BICEKugUKBAQBAgESBKMBAh4aqwUqCiBDdXJyZW50IHRy" + 
        "YWNraW5nIHN0YXR1cyBvZiB0aGUgUXVlc3QgZGV2aWNlLgogCiB0cnVlOiAgUXVlc3QgaXMgYWN0aXZl" + 
        "bHkgdHJhY2tpbmcgYW5kIHBvc2UgZGF0YSBpcyByZWxpYWJsZQogZmFsc2U6IFF1ZXN0IGhhcyBsb3N0" + 
        "IHRyYWNraW5nIGFuZCBwb3NlIGRhdGEgc2hvdWxkIG5vdCBiZSB0cnVzdGVkCiAKIFdoZW4gdHJhY2tp" + 
        "bmcgaXMgbG9zdDoKIC0gUG9zZSBkYXRhIGJlY29tZXMgc3RhbGUgYW5kIHVucmVsaWFibGUKIC0gUm9i" + 
        "b3Qgc2hvdWxkIHN3aXRjaCB0byBhbHRlcm5hdGl2ZSBsb2NhbGl6YXRpb24gbWV0aG9kcwogLSBNb3Zl" + 
        "bWVudCBzaG91bGQgYmUgbGltaXRlZCBvciBzdG9wcGVkIGZvciBzYWZldHkKIAogVHJhY2tpbmcgY2Fu" + 
        "IGJlIHJlY292ZXJlZCBieToKIC0gSW1wcm92aW5nIGxpZ2h0aW5nIGNvbmRpdGlvbnMKIC0gTW92aW5n" + 
        "IHRvIGFyZWEgd2l0aCBtb3JlIHZpc3VhbCBmZWF0dXJlcwogLSBSZWR1Y2luZyBtb3Rpb24gdG8gYWxs" + 
        "b3cgc3lzdGVtIHRvIHJlLWluaXRpYWxpemUKIC0gUGVyZm9ybWluZyBwb3NlIHJlc2V0IHdoZW4gdHJh" + 
        "Y2tpbmcgcmVjb3ZlcnMKIAogRXh0ZXJuYWwgc3lzdGVtcyBzaG91bGQgbW9uaXRvciB0aGlzIGZpZWxk" + 
        "IGFuZCBpbXBsZW1lbnQgYXBwcm9wcmlhdGUKIGZhbGxiYWNrIGJlaGF2aW9ycyB3aGVuIHRyYWNraW5n",
        "IGlzIGxvc3QuCgoNCgUEAQIBBRIEowECBgoNCgUEAQIBARIEowEHGQoNCgUEAQIBAxIEowEcHQraBQoE" + 
        "BAECAhIEvAECHBrLBSoKIFF1ZXN0IGRldmljZSBiYXR0ZXJ5IGxldmVsIGFzIGEgcGVyY2VudGFnZSAo" + 
        "MC0xMDApLgogCiBUaGlzIHByb3ZpZGVzIHRoZSBjdXJyZW50IGJhdHRlcnkgY2hhcmdlIGxldmVsIG9m" + 
        "IHRoZSBRdWVzdCBoZWFkc2V0LAogYWxsb3dpbmcgZXh0ZXJuYWwgc3lzdGVtcyB0bzoKIC0gTW9uaXRv" + 
        "ciBwb3dlciBzdGF0dXMgZHVyaW5nIG9wZXJhdGlvbgogLSBJbXBsZW1lbnQgbG93LWJhdHRlcnkgd2Fy" + 
        "bmluZ3Mgb3IgYmVoYXZpb3JzCiAtIFBsYW4gb3BlcmF0aW9uIGR1cmF0aW9uIGFuZCBjaGFyZ2luZyBu" + 
        "ZWVkcwogLSBUcmlnZ2VyIGdyYWNlZnVsIHNodXRkb3duIHByb2NlZHVyZXMKIAogQmF0dGVyeSBMZXZl" + 
        "bCBHdWlkZWxpbmVzOgogLSAxMDAlOiBGdWxseSBjaGFyZ2VkCiAtIDUwLTEwMCU6IE5vcm1hbCBvcGVy" + 
        "YXRpb24KIC0gMjAtNTAlOiBDb25zaWRlciBjaGFyZ2luZyBzb29uCiAtIDEwLTIwJTogTG93IGJhdHRl" + 
        "cnkgd2FybmluZyByZWNvbW1lbmRlZAogLSAwLTEwJTogQ3JpdGljYWwgLSBwbGFuIGltbWVkaWF0ZSBz" + 
        "aHV0ZG93bi9jaGFyZ2luZwogCiBOb3RlOiBCYXR0ZXJ5IGRyYWluIHJhdGUgZGVwZW5kcyBvbjoKIC0g" + 
        "UHJvY2Vzc2luZyBsb2FkICh0cmFja2luZyBjb21wbGV4aXR5KQogLSBEaXNwbGF5IHVzYWdlIChpZiBh" + 
        "bnkpCiAtIFdpcmVsZXNzIGNvbW11bmljYXRpb24gYWN0aXZpdHkKIC0gRW52aXJvbm1lbnRhbCB0ZW1w" + 
        "ZXJhdHVyZQoKDQoFBAECAgUSBLwBAgcKDQoFBAECAgESBLwBCBcKDQoFBAECAgMSBLwBGhtiBnByb3Rv" + 
        "Mw==");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("data.proto", "questnav.protos.data", descriptorData, Geometry2D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavFrameData_descriptor = descriptor.internalContainedType(55, 141, "ProtobufQuestNavFrameData", "questnav.protos.data.ProtobufQuestNavFrameData");

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavDeviceData_descriptor = descriptor.internalContainedType(199, 168, "ProtobufQuestNavDeviceData", "questnav.protos.data.ProtobufQuestNavDeviceData");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     * *
     *  High-frequency tracking data sent from Quest to external systems.
     *  
     *  This message contains the core tracking information that external systems
     *  (like robot code) need for real-time localization and navigation. It's sent
     *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
     *  
     *  The data represents the Quest's position and orientation on the field,
     *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - Origin and axes depend on field setup and calibration
     *  - Pose represents the Quest's position; mounting offset to get robot position
     *    is applied in end user code
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavFrameData}
     */
    public static final class ProtobufQuestNavFrameData extends ProtoMessage<ProtobufQuestNavFrameData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         */
        private double timestamp;

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         */
        private int frameCount;

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         */
        private final Geometry2D.ProtobufPose2d pose2D = Geometry2D.ProtobufPose2d.newInstance();

        private ProtobufQuestNavFrameData() {
        }

        /**
         * <pre>
         * *
         *  High-frequency tracking data sent from Quest to external systems.
         *  
         *  This message contains the core tracking information that external systems
         *  (like robot code) need for real-time localization and navigation. It's sent
         *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
         *  
         *  The data represents the Quest's position and orientation on the field,
         *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - Origin and axes depend on field setup and calibration
         *  - Pose represents the Quest's position; mounting offset to get robot position
         *    is applied in end user code
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavFrameData}
         */
        public static ProtobufQuestNavFrameData newInstance() {
            return new ProtobufQuestNavFrameData();
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return whether the timestamp field is set
         */
        public boolean hasTimestamp() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearTimestamp() {
            bitField0_ &= ~0x00000001;
            timestamp = 0D;
            return this;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return the timestamp
         */
        public double getTimestamp() {
            return timestamp;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @param value the timestamp to set
         * @return this
         */
        public ProtobufQuestNavFrameData setTimestamp(final double value) {
            bitField0_ |= 0x00000001;
            timestamp = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return whether the frameCount field is set
         */
        public boolean hasFrameCount() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearFrameCount() {
            bitField0_ &= ~0x00000002;
            frameCount = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return the frameCount
         */
        public int getFrameCount() {
            return frameCount;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @param value the frameCount to set
         * @return this
         */
        public ProtobufQuestNavFrameData setFrameCount(final int value) {
            bitField0_ |= 0x00000002;
            frameCount = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @return whether the pose2D field is set
         */
        public boolean hasPose2D() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearPose2D() {
            bitField0_ &= ~0x00000004;
            pose2D.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePose2D()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry2D.ProtobufPose2d getPose2D() {
            return pose2D;
        }

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry2D.ProtobufPose2d getMutablePose2D() {
            bitField0_ |= 0x00000004;
            return pose2D;
        }

        /**
         * <pre>
         * *
         *  Quest's 2D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)  
         *  - Rotation: Counter-clockwise positive (radians)
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose2d pose2d = 3;</code>
         * @param value the pose2D to set
         * @return this
         */
        public ProtobufQuestNavFrameData setPose2D(final Geometry2D.ProtobufPose2d value) {
            bitField0_ |= 0x00000004;
            pose2D.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData copyFrom(final ProtobufQuestNavFrameData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                timestamp = other.timestamp;
                frameCount = other.frameCount;
                pose2D.copyFrom(other.pose2D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final ProtobufQuestNavFrameData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTimestamp()) {
                setTimestamp(other.timestamp);
            }
            if (other.hasFrameCount()) {
                setFrameCount(other.frameCount);
            }
            if (other.hasPose2D()) {
                getMutablePose2D().mergeFrom(other.pose2D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            timestamp = 0D;
            frameCount = 0;
            pose2D.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            pose2D.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavFrameData)) {
                return false;
            }
            ProtobufQuestNavFrameData other = (ProtobufQuestNavFrameData) o;
            return bitField0_ == other.bitField0_
                && (!hasTimestamp() || ProtoUtil.isEqual(timestamp, other.timestamp))
                && (!hasFrameCount() || frameCount == other.frameCount)
                && (!hasPose2D() || pose2D.equals(other.pose2D));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 17);
                output.writeDoubleNoTag(timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeMessageNoTag(pose2D);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 9;
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(pose2D);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavFrameData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 17: {
                        // timestamp
                        timestamp = input.readDouble();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // frameCount
                        frameCount = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // pose2D
                        input.readMessage(pose2D);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeDouble(FieldNames.timestamp, timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.frameCount, frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeMessage(FieldNames.pose2D, pose2D);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 55126294: {
                        if (input.isAtField(FieldNames.timestamp)) {
                            if (!input.trySkipNullValue()) {
                                timestamp = input.readDouble();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -296512606:
                    case 188405693: {
                        if (input.isAtField(FieldNames.frameCount)) {
                            if (!input.trySkipNullValue()) {
                                frameCount = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -982466877: {
                        if (input.isAtField(FieldNames.pose2D)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(pose2D);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clone() {
            return new ProtobufQuestNavFrameData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavFrameData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), data).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavFrameData messages
         */
        public static MessageFactory<ProtobufQuestNavFrameData> getFactory() {
            return ProtobufQuestNavFrameDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavFrameData_descriptor;
        }

        private enum ProtobufQuestNavFrameDataFactory implements MessageFactory<ProtobufQuestNavFrameData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavFrameData create() {
                return ProtobufQuestNavFrameData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName timestamp = FieldName.forField("timestamp");

            static final FieldName frameCount = FieldName.forField("frameCount", "frame_count");

            static final FieldName pose2D = FieldName.forField("pose2d");
        }
    }

    /**
     * <pre>
     * *
     *  Lower-frequency device status data sent from Quest to external systems.
     *  
     *  This message contains device health and status information that doesn't need
     *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
     *  to provide monitoring and diagnostic information without consuming excessive
     *  bandwidth.
     *  
     *  This data helps external systems:
     *  - Monitor Quest device health
     *  - Detect tracking system issues
     *  - Implement failsafe behaviors
     *  - Provide user feedback about system status
     *  
     *  The information is useful for both autonomous operation and debugging/
     *  troubleshooting scenarios.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavDeviceData}
     */
    public static final class ProtobufQuestNavDeviceData extends ProtoMessage<ProtobufQuestNavDeviceData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         */
        private int trackingLostCounter;

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         */
        private int batteryPercent;

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         */
        private boolean currentlyTracking;

        private ProtobufQuestNavDeviceData() {
        }

        /**
         * <pre>
         * *
         *  Lower-frequency device status data sent from Quest to external systems.
         *  
         *  This message contains device health and status information that doesn't need
         *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
         *  to provide monitoring and diagnostic information without consuming excessive
         *  bandwidth.
         *  
         *  This data helps external systems:
         *  - Monitor Quest device health
         *  - Detect tracking system issues
         *  - Implement failsafe behaviors
         *  - Provide user feedback about system status
         *  
         *  The information is useful for both autonomous operation and debugging/
         *  troubleshooting scenarios.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavDeviceData}
         */
        public static ProtobufQuestNavDeviceData newInstance() {
            return new ProtobufQuestNavDeviceData();
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return whether the trackingLostCounter field is set
         */
        public boolean hasTrackingLostCounter() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearTrackingLostCounter() {
            bitField0_ &= ~0x00000001;
            trackingLostCounter = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return the trackingLostCounter
         */
        public int getTrackingLostCounter() {
            return trackingLostCounter;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @param value the trackingLostCounter to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setTrackingLostCounter(final int value) {
            bitField0_ |= 0x00000001;
            trackingLostCounter = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return whether the batteryPercent field is set
         */
        public boolean hasBatteryPercent() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearBatteryPercent() {
            bitField0_ &= ~0x00000002;
            batteryPercent = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return the batteryPercent
         */
        public int getBatteryPercent() {
            return batteryPercent;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @param value the batteryPercent to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setBatteryPercent(final int value) {
            bitField0_ |= 0x00000002;
            batteryPercent = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return whether the currentlyTracking field is set
         */
        public boolean hasCurrentlyTracking() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearCurrentlyTracking() {
            bitField0_ &= ~0x00000004;
            currentlyTracking = false;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return the currentlyTracking
         */
        public boolean getCurrentlyTracking() {
            return currentlyTracking;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @param value the currentlyTracking to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setCurrentlyTracking(final boolean value) {
            bitField0_ |= 0x00000004;
            currentlyTracking = value;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData copyFrom(final ProtobufQuestNavDeviceData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                trackingLostCounter = other.trackingLostCounter;
                batteryPercent = other.batteryPercent;
                currentlyTracking = other.currentlyTracking;
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final ProtobufQuestNavDeviceData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTrackingLostCounter()) {
                setTrackingLostCounter(other.trackingLostCounter);
            }
            if (other.hasBatteryPercent()) {
                setBatteryPercent(other.batteryPercent);
            }
            if (other.hasCurrentlyTracking()) {
                setCurrentlyTracking(other.currentlyTracking);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            trackingLostCounter = 0;
            batteryPercent = 0;
            currentlyTracking = false;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavDeviceData)) {
                return false;
            }
            ProtobufQuestNavDeviceData other = (ProtobufQuestNavDeviceData) o;
            return bitField0_ == other.bitField0_
                && (!hasTrackingLostCounter() || trackingLostCounter == other.trackingLostCounter)
                && (!hasBatteryPercent() || batteryPercent == other.batteryPercent)
                && (!hasCurrentlyTracking() || currentlyTracking == other.currentlyTracking);
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 24);
                output.writeInt32NoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(currentlyTracking);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 2;
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavDeviceData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // trackingLostCounter
                        trackingLostCounter = input.readInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // batteryPercent
                        batteryPercent = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // currentlyTracking
                        currentlyTracking = input.readBool();
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeInt32(FieldNames.trackingLostCounter, trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.batteryPercent, batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeBool(FieldNames.currentlyTracking, currentlyTracking);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1237870847:
                    case -2011984791: {
                        if (input.isAtField(FieldNames.trackingLostCounter)) {
                            if (!input.trySkipNullValue()) {
                                trackingLostCounter = input.readInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -2041653896:
                    case -1975165933: {
                        if (input.isAtField(FieldNames.batteryPercent)) {
                            if (!input.trySkipNullValue()) {
                                batteryPercent = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 879013277:
                    case 106200592: {
                        if (input.isAtField(FieldNames.currentlyTracking)) {
                            if (!input.trySkipNullValue()) {
                                currentlyTracking = input.readBool();
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clone() {
            return new ProtobufQuestNavDeviceData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavDeviceData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), data).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavDeviceData messages
         */
        public static MessageFactory<ProtobufQuestNavDeviceData> getFactory() {
            return ProtobufQuestNavDeviceDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavDeviceData_descriptor;
        }

        private enum ProtobufQuestNavDeviceDataFactory implements MessageFactory<ProtobufQuestNavDeviceData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavDeviceData create() {
                return ProtobufQuestNavDeviceData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName trackingLostCounter = FieldName.forField("trackingLostCounter", "tracking_lost_counter");

            static final FieldName batteryPercent = FieldName.forField("batteryPercent", "battery_percent");

            static final FieldName currentlyTracking = FieldName.forField("currentlyTracking", "currently_tracking");
        }
    }
}
