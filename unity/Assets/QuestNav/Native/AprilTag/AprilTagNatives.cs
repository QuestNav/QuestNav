using System;
using System.Runtime.InteropServices;

namespace QuestNav.Native.AprilTag
{
    /// <summary>
    /// Represents coordinates of a AprilTag detection
    /// </summary>
    /// <code>
    /// struct quad
    /// {
    ///     float p[4][2]; // corners
    ///     bool reversed_border;
    /// 
    ///     // H: tag coordinates ([-1,1] at the black corners) to pixels
    ///     // Hinv: pixels to tag
    ///     matd_t *H, *Hinv;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct Quad
    {
        public fixed float p[8]; // [4][2] flattened to [8]

        [MarshalAs(UnmanagedType.I1)]
        public bool reversed_border;

        public IntPtr H;
        public IntPtr Hinv;
    }

    /// <summary>
    /// Represents a tag family. Every tag belongs to a tag family. Tag
    /// families are generated by the Java tool
    /// april.tag.TagFamilyGenerator and can be converted to C using
    /// april.tag.TagToC.
    /// </summary>
    /// <code>
    /// struct apriltag_family
    /// {
    ///     // How many codes are there in this tag family?
    ///     uint32_t ncodes;
    /// 
    ///     // The codes in the family.
    ///     uint64_t *codes;
    /// 
    ///     int width_at_border;
    ///     int total_width;
    ///     bool reversed_border;
    /// 
    ///     // The bit locations.
    ///     uint32_t nbits;
    ///     uint32_t *bit_x;
    ///     uint32_t *bit_y;
    /// 
    ///     // minimum hamming distance between any two codes. (e.g. 36h11 => 11)
    ///     uint32_t h;
    /// 
    ///     // a human-readable name, e.g., "tag36h11"
    ///     char *name;
    /// 
    ///     // some detector implementations may preprocess codes in order to
    ///     // accelerate decoding.  They put their data here. (Do not use the
    ///     // same apriltag_family instance in more than one implementation)
    ///     void *impl;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct ApriltagFamily
    {
        public uint ncodes;
        public IntPtr codes;
        public int width_at_border;
        public int total_width;

        [MarshalAs(UnmanagedType.I1)]
        public bool reversed_border;
        public uint nbits;
        public IntPtr bit_x;
        public IntPtr bit_y;
        public uint h;

        [MarshalAs(UnmanagedType.LPStr)]
        public string name;
        public IntPtr impl;
    }

    /// <summary>
    /// Parameters for quad detection threshold processing
    /// </summary>
    /// <code>
    /// struct apriltag_quad_thresh_params
    /// {
    ///     // reject quads containing too few pixels
    ///     int min_cluster_pixels;
    /// 
    ///     // how many corner candidates to consider when segmenting a group
    ///     // of pixels into a quad.
    ///     int max_nmaxima;
    /// 
    ///     // Reject quads where pairs of edges have angles that are close to
    ///     // straight or close to 180 degrees. Zero means that no quads are
    ///     // rejected. (In radians).
    ///     float critical_rad;
    ///     float cos_critical_rad;
    /// 
    ///     // When fitting lines to the contours, what is the maximum mean
    ///     // squared error allowed?  This is useful in rejecting contours
    ///     // that are far from being quad shaped; rejecting these quads "early"
    ///     // saves expensive decoding processing.
    ///     float max_line_fit_mse;
    /// 
    ///     // When we build our model of black & white pixels, we add an
    ///     // extra check that the white model must be (overall) brighter
    ///     // than the black model.  How much brighter? (in pixel values,
    ///     // [0,255]). .
    ///     int min_white_black_diff;
    /// 
    ///     // should the thresholded image be deglitched? Only useful for
    ///     // very noisy images
    ///     int deglitch;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct ApriltagQuadThreshParams
    {
        // reject quads containing too few pixels
        public int min_cluster_pixels;

        // how many corner candidates to consider when segmenting a group
        // of pixels into a quad.
        public int max_nmaxima;

        // Reject quads where pairs of edges have angles that are close to
        // straight or close to 180 degrees. Zero means that no quads are
        // rejected. (In radians).
        public float critical_rad;
        public float cos_critical_rad;

        // When fitting lines to the contours, what is the maximum mean
        // squared error allowed?  This is useful in rejecting contours
        // that are far from being quad shaped; rejecting these quads "early"
        // saves expensive decoding processing.
        public float max_line_fit_mse;

        // When we build our model of black & white pixels, we add an
        // extra check that the white model must be (overall) brighter
        // than the black model.  How much brighter? (in pixel values,
        // [0,255]).
        public int min_white_black_diff;

        // should the thresholded image be deglitched? Only useful for
        // very noisy images
        public int deglitch;
    }

    /// <summary>
    /// Represents a detector object. Upon creating a detector, all fields
    /// are set to reasonable values, but can be overridden by accessing
    /// these fields.
    /// </summary>
    /// <code>
    /// struct apriltag_detector
    /// {
    ///     ///////////////////////////////////////////////////////////////
    ///     // User-configurable parameters.
    /// 
    ///     // How many threads should be used?
    ///     int nthreads;
    /// 
    ///     // detection of quads can be done on a lower-resolution image,
    ///     // improving speed at a cost of pose accuracy and a slight
    ///     // decrease in detection rate. Decoding the binary payload is
    ///     // still done at full resolution. .
    ///     float quad_decimate;
    /// 
    ///     // What Gaussian blur should be applied to the segmented image
    ///     // (used for quad detection?)  Parameter is the standard deviation
    ///     // in pixels.  Very noisy images benefit from non-zero values
    ///     // (e.g. 0.8).
    ///     float quad_sigma;
    /// 
    ///     // When true, the edges of the each quad are adjusted to "snap
    ///     // to" strong gradients nearby. This is useful when decimation is
    ///     // employed, as it can increase the quality of the initial quad
    ///     // estimate substantially. Generally recommended to be on (true).
    ///     //
    ///     // Very computationally inexpensive. Option is ignored if
    ///     // quad_decimate = 1.
    ///     bool refine_edges;
    /// 
    ///     // How much sharpening should be done to decoded images? This
    ///     // can help decode small tags but may or may not help in odd
    ///     // lighting conditions or low light conditions.
    ///     //
    ///     // The default value is 0.25.
    ///     double decode_sharpening;
    /// 
    ///     // When true, write a variety of debugging images to the
    ///     // current working directory at various stages through the
    ///     // detection process. (Somewhat slow).
    ///     bool debug;
    /// 
    ///     struct apriltag_quad_thresh_params qtp;
    /// 
    ///     ///////////////////////////////////////////////////////////////
    ///     // Statistics relating to last processed frame
    ///     timeprofile_t *tp;
    /// 
    ///     uint32_t nedges;
    ///     uint32_t nsegments;
    ///     uint32_t nquads;
    /// 
    ///     ///////////////////////////////////////////////////////////////
    ///     // Internal variables below
    /// 
    ///     // Not freed on apriltag_destroy; a tag family can be shared
    ///     // between multiple users. The user should ultimately destroy the
    ///     // tag family passed into the constructor.
    ///     zarray_t *tag_families;
    /// 
    ///     // Used to manage multi-threading.
    ///     workerpool_t *wp;
    /// 
    ///     // Used for thread safety.
    ///     pthread_mutex_t mutex;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct AprilTagDetector
    {
        ///////////////////////////////////////////////////////////////
        // User-configurable parameters.

        // How many threads should be used?
        int nthreads;

        // detection of quads can be done on a lower-resolution image,
        // improving speed at a cost of pose accuracy and a slight
        // decrease in detection rate. Decoding the binary payload is
        // still done at full resolution. .
        float quad_decimate;

        // What Gaussian blur should be applied to the segmented image
        // (used for quad detection?)  Parameter is the standard deviation
        // in pixels.  Very noisy images benefit from non-zero values
        // (e.g. 0.8).
        float quad_sigma;

        // When true, the edges of the each quad are adjusted to "snap
        // to" strong gradients nearby. This is useful when decimation is
        // employed, as it can increase the quality of the initial quad
        // estimate substantially. Generally recommended to be on (true).
        //
        // Very computationally inexpensive. Option is ignored if
        // quad_decimate = 1.
        [MarshalAs(UnmanagedType.I1)]
        bool refine_edges;

        // How much sharpening should be done to decoded images? This
        // can help decode small tags but may or may not help in odd
        // lighting conditions or low light conditions.
        //
        // The default value is 0.25.
        double decode_sharpening;

        // When true, write a variety of debugging images to the
        // current working directory at various stages through the
        // detection process. (Somewhat slow).
        [MarshalAs(UnmanagedType.I1)]
        bool debug;

        public ApriltagQuadThreshParams qtp;

        ///////////////////////////////////////////////////////////////
        // Statistics relating to last processed frame
        public IntPtr tp;

        public uint nedges;
        public uint nsegments;
        public uint nquads;

        ///////////////////////////////////////////////////////////////
        // Internal variables below

        // Not freed on apriltag_destroy; a tag family can be shared
        // between multiple users. The user should ultimately destroy the
        // tag family passed into the constructor.
        public IntPtr tag_families;

        // Used to manage multi-threading.
        public IntPtr wp;

        // Used for thread safety.
        public IntPtr mutex;
    }

    /// <summary>
    /// Represents the detection of a tag. These are returned to the user
    /// and must be individually destroyed by the user.
    /// </summary>
    /// <code>
    /// struct apriltag_detection
    /// {
    ///     // a pointer for convenience. not freed by apriltag_detection_destroy.
    ///     apriltag_family_t *family;
    /// 
    ///     // The decoded ID of the tag
    ///     int id;
    /// 
    ///     // How many error bits were corrected? Note: accepting large numbers of
    ///     // corrected errors leads to greatly increased false positive rates.
    ///     // NOTE: As of this implementation, the detector cannot detect tags with
    ///     // a hamming distance greater than 2.
    ///     int hamming;
    /// 
    ///     // A measure of the quality of the binary decoding process: the
    ///     // average difference between the intensity of a data bit versus
    ///     // the decision threshold. Higher numbers roughly indicate better
    ///     // decodes. This is a reasonable measure of detection accuracy
    ///     // only for very small tags-- not effective for larger tags (where
    ///     // we could have sampled anywhere within a bit cell and still
    ///     // gotten a good detection.)
    ///     float decision_margin;
    /// 
    ///     // The 3x3 homography matrix describing the projection from an
    ///     // "ideal" tag (with corners at (-1,1), (1,1), (1,-1), and (-1,
    ///     // -1)) to pixels in the image. This matrix will be freed by
    ///     // apriltag_detection_destroy.
    ///     matd_t *H;
    /// 
    ///     // The center of the detection in image pixel coordinates.
    ///     double c[2];
    /// 
    ///     // The corners of the tag in image pixel coordinates. These always
    ///     // wrap counter-clock wise around the tag.
    ///     double p[4][2];
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct AprilTagDetection
    {
        // a pointer for convenience. not freed by apriltag_detection_destroy.
        public IntPtr family;

        // The decoded ID of the tag
        int id;

        // How many error bits were corrected? Note: accepting large numbers of
        // corrected errors leads to greatly increased false positive rates.
        // NOTE: As of this implementation, the detector cannot detect tags with
        // a hamming distance greater than 2.
        int hamming;

        // A measure of the quality of the binary decoding process: the
        // average difference between the intensity of a data bit versus
        // the decision threshold. Higher numbers roughly indicate better
        // decodes. This is a reasonable measure of detection accuracy
        // only for very small tags-- not effective for larger tags (where
        // we could have sampled anywhere within a bit cell and still
        // gotten a good detection.)
        float decision_margin;

        // The 3x3 homography matrix describing the projection from an
        // "ideal" tag (with corners at (-1,1), (1,1), (1,-1), and (-1,
        // -1)) to pixels in the image. This matrix will be freed by
        // apriltag_detection_destroy.
        public IntPtr H;

        // The center of the detection in image pixel coordinates.
        public fixed double c[2];

        // The corners of the tag in image pixel coordinates. These always
        // wrap counter-clock wise around the tag.
        public fixed double p[8]; // [4][2] flattened to [8]
    }

    /// <summary>
    /// Information needed for pose estimation of an AprilTag detection
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ApriltagDetectionInfo
    {
        // Pointer to the detection struct
        public IntPtr det; // apriltag_detection_t* det

        // Tag size in meters
        public double tagsize;

        // Camera intrinsic parameters (in pixels)
        public double fx; // Focal length X
        public double fy; // Focal length Y
        public double cx; // Principal point X
        public double cy; // Principal point Y
    }

    /// <summary>
    /// Represents the pose (position and orientation) of a detected AprilTag
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct AprilTagPose
    {
        public IntPtr R; // Rotation matrix 3x3 of doubles.
        public IntPtr t; // Translation matrix 3x1 of doubles.
    }

    public unsafe class AprilTagNatives
    {
        /// <summary>
        /// Creates a new AprilTag detector with default parameters.
        /// Don't forget to add a family!
        /// </summary>
        /// <returns>Pointer to the created apriltag_detector_t</returns>
        /// <code>
        /// apriltag_detector_t *apriltag_detector_create();
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr apriltag_detector_create();

        /// <summary>
        /// Add a family to the apriltag detector. Caller still "owns" the family.
        /// A single instance should only be provided to one apriltag detector instance.
        /// </summary>
        /// <param name="td">The detector to add the family to</param>
        /// <param name="fam">The tag family to add</param>
        /// <param name="bits_corrected">Number of error correction bits</param>
        /// <code>
        /// void apriltag_detector_add_family_bits(apriltag_detector_t *td, apriltag_family_t *fam, int bits_corrected);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_add_family_bits(
            IntPtr td,
            IntPtr fam,
            int bits_corrected
        );

        /// <summary>
        /// Add a family to the apriltag detector with default error correction (2 bits).
        /// Tunable, but really, 2 is a good choice. Values of >=3
        /// consume prohibitively large amounts of memory, and otherwise
        /// you want the largest value possible.
        /// </summary>
        /// <param name="td">The detector to add the family to</param>
        /// <param name="fam">The tag family to add</param>
        /// <code>
        /// static inline void apriltag_detector_add_family(apriltag_detector_t *td, apriltag_family_t *fam)
        /// {
        ///     apriltag_detector_add_family_bits(td, fam, 2);
        /// }
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_add_family(IntPtr td, IntPtr fam);

        /// <summary>
        /// Remove a family from the apriltag detector.
        /// Does not deallocate the family.
        /// </summary>
        /// <param name="td">The detector to remove the family from</param>
        /// <param name="fam">The tag family to remove</param>
        /// <code>
        /// void apriltag_detector_remove_family(apriltag_detector_t *td, apriltag_family_t *fam);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_remove_family(IntPtr td, IntPtr fam);

        /// <summary>
        /// Unregister all families from the detector, but does not deallocate the underlying tag family objects.
        /// </summary>
        /// <param name="td">The detector to clear families from</param>
        /// <code>
        /// void apriltag_detector_clear_families(apriltag_detector_t *td);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_clear_families(IntPtr td);

        /// <summary>
        /// Destroy the april tag detector (but not the underlying
        /// apriltag_family_t used to initialize it.)
        /// </summary>
        /// <param name="td">The detector to destroy</param>
        /// <code>
        /// void apriltag_detector_destroy(apriltag_detector_t *td);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_destroy(IntPtr td);

        /// <summary>
        /// Detect tags from an image and return an array of apriltag_detection_t*.
        /// You can use apriltag_detections_destroy to free the array and the detections it contains,
        /// or call _detection_destroy and zarray_destroy yourself.
        /// </summary>
        /// <param name="td">The detector to use</param>
        /// <param name="im_orig">The image to process</param>
        /// <returns>zarray_t* containing apriltag_detection_t* elements</returns>
        /// <code>
        /// zarray_t *apriltag_detector_detect(apriltag_detector_t *td, image_u8_t *im_orig);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr apriltag_detector_detect(IntPtr td, IntPtr im_orig);

        /// <summary>
        /// Call this method on each of the tags returned by apriltag_detector_detect
        /// to free the memory associated with the detection.
        /// </summary>
        /// <param name="det">The detection to destroy</param>
        /// <code>
        /// void apriltag_detection_destroy(apriltag_detection_t *det);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detection_destroy(IntPtr det);

        /// <summary>
        /// Destroys the array AND the detections within it.
        /// </summary>
        /// <param name="detections">The zarray_t* containing detections to destroy</param>
        /// <code>
        /// void apriltag_detections_destroy(zarray_t *detections);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detections_destroy(IntPtr detections);

        /// <summary>
        /// Renders the apriltag to an image.
        /// Caller is responsible for calling image_u8_destroy on the returned image.
        /// </summary>
        /// <param name="fam">The tag family</param>
        /// <param name="idx">The tag index within the family</param>
        /// <returns>image_u8_t* containing the rendered tag</returns>
        /// <code>
        /// image_u8_t *apriltag_to_image(apriltag_family_t *fam, uint32_t idx);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr apriltag_to_image(IntPtr fam, uint idx);
        
        /// <summary>
        /// Estimates the pose of a detected AprilTag given camera intrinsic parameters and tag size.
        /// </summary>
        /// <param name="info">Pointer to ApriltagDetectionInfo struct containing detection data and camera parameters</param>
        /// <param name="pose">Pointer to AprilTagPose struct where the estimated pose will be stored</param>
        /// <returns>The reprojection error of the pose estimation</returns>
        /// <code>
        /// double estimate_tag_pose(apriltag_detection_info_t *info, apriltag_pose_t *pose);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern double estimate_tag_pose(IntPtr info, IntPtr pose);

        /// <summary>
        /// Creates a new tag36h11 family instance.
        /// The tag36h11 family contains 587 tags with 11-bit error correction.
        /// Caller is responsible for destroying the family with tag36h11_destroy.
        /// </summary>
        /// <returns>Pointer to the created apriltag_family_t for tag36h11</returns>
        /// <code>
        /// apriltag_family_t *tag36h11_create();
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr tag36h11_create();

        /// <summary>
        /// Destroys a tag36h11 family instance and frees associated memory.
        /// </summary>
        /// <param name="tf">Pointer to the tag36h11 family to destroy</param>
        /// <code>
        /// void tag36h11_destroy(apriltag_family_t *tf);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void tag36h11_destroy(IntPtr tf);
    }
}